-*- mode: org; fill-column: 80; eval: (display-fill-column-indicator-mode -1); -*-
#+title: Emacs Core
#+author: James Dyer
#+options: toc:nil author:t title:t
#+startup: showall
#+todo: TODO DOING | DONE
#+property: header-args :tangle ~/.emacs.d/Emacs-core/init.el

#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
#+end_src

* Introduction

*Emacs-core* is a stripped-down version of my primary Emacs configuration. It is designed to leverage only the default built-in features of Emacs (v27.1 and later). This makes it ideal for virtual machines or scenarios where you need a fast, package-free Emacs setup that works out of the box on most systems.

Supported Platforms:
- SUSE Linux Enterprise (SLES15)
- SwayWM - Wayland
- Windows 10

Looking to potentially support:
- OpenSuse 11.2 (November 12, 2009)

The configuration focuses on ease of use by providing custom keybindings, basic completion support, and visual enhancements without relying on any external packages.

Note that this package works in combination with https://github.com/captainflasmr/Emacs-enhanced which is a conversion of major Emacs packages / functions, especially ones that I rely on to single defuns.

* Whats New

** <2024-12-18>

Replaced tempel with abbrev, will have to write a blog post about this but replacing the following tempel template :

#+begin_src fundamental :tangle no
fundamental-mode ;; Available everywhere
;;
(ja (format-time-string "<%Y-%m-%d>"))
(jT (format-time-string "%Y%m%d%H%M%S"))
(jt (format-time-string "%Y%m%d"))
(ji "(interactive)")
(jl "(lambda ()")
;;
org-mode
;;
(jm "#+hugo: more")
(jg "#+attr_org: :width 300px" n "#+attr_html: :width 100%")
(je "#+attr_org: :width 300px" n "#+attr_html: :class emacs-img")
(jo "---" n "#+TOC: headlines 1 local" n "---")
(jk "#+begin: kanban :layout (\"...\" . 40) :scope nil :range (\"TODO\" . \"DONE\") :sort \"O\" :depth 2 :compressed t" n "#+end:")
(jp "~--APT--~ ")
;;
sh-mode
(jd n "echo \"poop: " p "\"" n)
;;
emacs-lisp-mode
(jd n "(message \"poop: " p "\"\)" n)
;;
ada-mode
(jd n> "Ada.Text_Io.Put_Line \( \"poop: " p "\"\);" n)
;;
c++-mode
(jd n> "std::cout << \"poop: " p "\" << std::endl;" n)
;;
c-mode
(jd n> "fprintf(stderr, \"poop: " p "\"\);" n)
#+end_src

with the following abbrev =abbrev_defs=:

#+begin_src fundamental-mode :tangle no
;;-*-coding: utf-8;-*-
(define-abbrev-table 'ada-mode-abbrev-table
  '(
    ("jd" "Ada.Text_Io.Put_Line (\"poop: \");" nil :count 0)
   ))
(define-abbrev-table 'c++-mode-abbrev-table
  '(
    ("jd" "std::cout << \"poop: \" << std::endl;" nil :count 0)
   ))
(define-abbrev-table 'c-mode-abbrev-table
  '(
    ("jd" "printf(stderr, \"poop: \");" nil :count 0)
   ))
(define-abbrev-table 'emacs-lisp-mode-abbrev-table
  '(
    ("jd" "(message \"poop: \")" nil :count 0)
   ))
(define-abbrev-table 'global-abbrev-table
  '(
    ("jT" "" (lambda nil (interactive) (insert (format-time-string "%Y%m%d%H%M%S"))) :count 0)
    ("ja" "" (lambda nil (interactive) (insert (format-time-string "<%Y-%m-%d>"))) :count 1)
    ("ji" "(interactive)" nil :count 1)
    ("jl" "(lambda ()" nil :count 0)
    ("jt" "" (lambda nil (interactive) (insert (format-time-string "%Y%m%d"))) :count 0)
   ))
(define-abbrev-table 'org-mode-abbrev-table
  '(
    ("je" "#+attr_org: :width 300px
,#+attr_html: :class emacs-img" nil :count 0)
    ("jg" "#+attr_org: :width 300px
,#+attr_html: :width 100%" nil :count 0)
    ("jk" "#+begin: kanban :layout (\"...\") :scope nil :range (\"TODO\" . \"DONE\") :sort \"O\" :depth 2 :compressed t
,#+end:" nil :count 0)
    ("jm" "#+hugo: more" nil :count 0)
    ("jo" "---
,#+TOC: headlines 1 local
---" nil :count 0)
    ("jp" "~--APT--~" nil :count 0)
   ))
(define-abbrev-table 'sh-mode-abbrev-table
  '(
    ("jd" "echo \"poop: \"" nil :count 0)
   ))
#+end_src

** <2024-12-16>

feat(emacs): Enhance =dired= and =image-dired= configurations

- *=dired=*:
  - Added a new keybinding (=C-c i=) for =my/image-dired-sort=.
  - Improved file management capabilities within Dired interface.

- *Spell-checking*:
  - Integrated =dictionary.el= for on-the-fly word definitions.
  - Added =C-c s d= for dictionary lookup.
  - Introduced =C-0= as dedicated keybinding for =ispell-word=.

- *=image-dired=*:
  - Introduced custom behavior for image manipulation:
    - Added =my/image-dired-sort= for better image sorting in Dired.
    - Defined keybindings to streamline navigation and editing in =image-dired=.
  - Configured a split-buffer layout for enhanced productivity.
  - Added helper functions (=my/image-save-as=, =my/delete-current-image-and-move-to-next=, etc.) for managing images programmatically.
  - Enabled external image viewing via =gthumb=.

** <2024-12-14>

Added my/find-file to be a more flexible ripgrep based finding file tool.

** <2024-12-14>

Added deadgrep kind of replacement called my/grep with leveraging ripgrep into a type of grep Emacs buffer.

** <2024-12-10>

Added ada-mode support out of the box.

Yes, ada-mode was removed from emacs and it was recommended to use the ada-mode supplied by AdaCore, however this is all but impossible to set up so including =ada-light=mode= as part of the configuration.

https://github.com/sebastianpoeplau/ada-light-mode

** <2024-12-09>

Added =visual-fill-column-mode= replacement with a simple elisp function (see solution in roadmap)

** <2024-12-09>

Added =my-icomplete-copy-candidate= to allow embark like copying of current candidate (see solution in roadmap)

** <2024-12-09>

Added =my/recentf-open= to bypass old default recentf-open interface (see solution in roadmap)

** <2024-12-09>

enhance window navigation and introduce my rainbow mode (see solution in roadmap)

- Refactored `my/quick-window-jump` for better window labeling and overlay management:
  - Improved window sorting logic for more accurate top-to-bottom, left-to-right navigation.
  - Added visual overlays to display window shortcuts with labels.
- Introduced `my/rainbow-mode`:
  - Overlays hex color values in buffers with their respective colors for better readability.
- Minor refactor to `my/copy-buffer-to-kill-ring` by removing redundant `save-excursion`.
- Corrected a typo: Renamed `identation-core` to `indentation-core`.
- Added `my/eglot-dir-locals` for ADA mode to simplify `.dir-locals.el` file creation:
  - Supports Eglot workspace configuration based on paths from Dired.
- Updated version control handling to consider only `SVN` and `Git` backends.

* Benefits

This emacs init configuration will provide me with the following benefits.

** Portability and Compatibility

- *Minimal setup across diverse platforms:*
  
  - Works seamlessly on almost any system where Emacs (v27.1+) is pre-installed or can be installed, without requiring internet access or additional dependencies.
  - Compatible with systems where external repositories like *MELPA* or *ELPA* are inaccessible (e.g., air-gapped systems, high-security environments, or restricted corporate setups).
  - Handles differences across disparate systems, such as:
    - *Linux (X11/Wayland):* Avoids reliance on GUI-based packages that may fail due to configuration mismatches.
    - *Windows:* Eliminates common issues like managing package archives, slow startup, or connectivity problems.
    - *macOS:* Works well even with the default version of Emacs shipped with macOS, many of which are compiled without key extensions.
- *Cross-version compatibility:*
  - Designed with vanilla Emacs features, ensuring it works across older and newer Emacs versions (limited to Emacs 27.1+ but avoiding bleeding-edge features of newer versions).

** Performance

- *Optimized for speed:*
  - Faster startup times due to the absence of external package initialization, byte-compilation of third-party libraries, or network lookup delays.
  - Fewer external dependencies mean less time spent on managing or resolving dependency-related issues.
- *Lightweight and resource-efficient:*
  - Avoids third-party packages that sometimes introduce memory bloat or unnecessary configuration overhead.
  - Perfect for virtual machines, resource-constrained systems, or environments requiring efficiency.

** Simplicity and Stability

- *Eliminates external dependencies:*
  - No need to depend on external package managers like MELPA, ELPA, or =straight.el=, making your setup resilient to upstream disruptions.
  - Reduces the risk of breakages introduced by updates to third-party packages.
- *Focuses on native capabilities:*
  - Encourages leveraging in-built Emacs functionality over bloated extensions, helping users master Emacs's native power.
  - Built-in features are generally well-tested and stable across versions, reducing the likelihood of incompatibilities or crashes.

** Usability

- *Beginner-friendly ethos:*
  - A simpler, package-free setup is ideal for teaching beginner users about Emacs, showing them how to rely on core features without the overwhelming complexity of third-party tools.
  - It introduces users to the elegance and power of vanilla Emacs, bypassing distractions from unnecessary packages.
- *Minimal maintenance:*
  - Excellent for situations where you need a reliable, pre-configured Emacs experience for short-term use (e.g., disposable environments, Docker containers, or ephemeral VMs).

** Practicality

- *Air-gapped and offline systems:*
  - Perfect for isolated networks where external package repositories are inaccessible for policy or security reasons.
  - Allows Emacs to remain functional for note-taking, scripting, or other tasks even in environments with no internet access.
- *Ease of distribution:*
  - Since the configuration doesnâ€™t require external dependencies, it can easily be shared or replicated across multiple machines.
  - Can be stored in a single file without the need for a long list of additional package installation instructions.
- *Ideal for DevOps and CI/CD pipelines:*
  - Useful in virtualized or containerized environments (e.g., Docker, CI runners) where you need a fast, reliable Emacs setup without pulling third-party tools.

** Security and Privacy

- *Better control over code and configuration:*
  - No automatic downloads or updates from external repositories, reducing the risk of introducing compromised or vulnerable code.
  - A completely self-contained configuration ensures no unexpected behaviour from unverified third-party plugins or libraries.
- *Privacy-friendly:*
  - No metadata is queried, and no connections are made to package repositories, ensuring greater privacy when using Emacs in sensitive environments.

** Encourages Learning and Mastery

- By restricting yourself to core Emacs functionality, you develop a deeper understanding of:
  - Efficient workflows based on what's built into Emacs.
  - How to solve problems creatively using only the default, extensible tools.
- Provides a solid foundation for customizing Emacs further once needed, without becoming overly dependent on external tools.

** Flexibility for Advanced Users

- *Base for users who prefer to build incrementally:*
  - Acts as a reliable "core" configuration, allowing users to selectively add new features as needed while minimizing risk and clutter.
  - Encourages selective evaluation of any third-party package for inclusion rather than indiscriminately combining external libraries.
- *Emphasis on timeless workflows:*
  - Built on enduring Emacs features that have been consistent for decades, ensuring compatibility even with older systems.
  - Can serve as an emergency fallback configuration for experienced users who rely on Emacs in more complex setups.

** Examples of Real-World Use Cases

- *Diagnostics tool:* You can use *Emacs-core* to debug whether an issue is related to third-party packages or stems from Emacs itself by testing the minimal configuration.
- *Always-ready portable editor:* Use it on systems where you're temporarily working without worrying about recreating your primary configuration.
- *Distraction-free writing:* Suited for scenarios where you want a fast, clean, and functional interface without additional bells and whistles.
- *VMs for testing or experimentation:* Perfect for virtual machines or containers where you need a low-maintenance Emacs that can be spun up quickly.

* Key Features

** Built-in Completion

- Default abbreviation expansion and predictive file/directory completion are implemented via =hippie-expand=.
  
- Minibuffer Configuration: Vanilla configuration achieved through enabling =fido-mode= provides an intuitive, fast, and clean completion interface in the minibuffer using the built-in =icomplete= framework without requiring third-party tools.

** Leveraging External Tools Where Possible

It is often advantageous to use *external tools* that are optimized for specific tasks. Emacs offers many built-in tools, but these may not always be the fastest or most feature-rich option available. By integrating with *system-based utilities* when they exist, we can achieve both performance improvements and enhanced capabilities. However, in cases where external tools are unavailable, Emacs' built-in options serve as a reliable fallback.

*** ripgrep - grepping files
**** Functionality
- Searching across project files for a specific term or pattern.
- Faster than Emacs' built-in =grep= or =rgrep=
- Better default handling of ignored files (e.g., =.gitignore= rules).
- Offers rich pattern matching (regex or literal strings).
**** Fallback
- Emacs' =grep= or =rgrep= commands provide file searching through built-in utilities like =grep=.
- While slower and less feature-rich, they can still handle basic directory searches.
*** ripgrep (alternative fd) - finding files
**** Functionality
- Searching for files in a directory or project.
- Supports advanced filtering options (e.g., searching by filename extension, ignoring gitignored files).
**** Fallback
- =find-name-dired= or =project-find-file= for locating files within Emacs projects.
- Relatively slower on larger directories, but sufficient for small-scale tasks.

** Keybindings for Navigation and Files

- Global Keybindings: Intuitive shortcut keys grant fast access to commonly used directories, files, and dired buffers. These can be configured to cater to personal file organization preferences.
  
- Tab and Buffer Management: Includes keybindings for:
  - Quickly creating, killing, and cycling through buffers.
  - Simplified navigation through tabs in Emacs (using its native tab-bar-mode or tab-line-mode).
  - Use mnemonic key combinations to =split=, =balance=, and =move= between windows, akin to tiling window managers.

** Window and Visual Controls

- Flexibly toggle visual Emacs elements such as:
  - Fonts (adjust point size with keyboard shortcuts).
  - Line numbers (switch between absolute and relative numbering).
  - Themes (light/dark mode switching via a single key).
  - Minor display elements like fringe, scrollbars, and menu bars depending on needs.
    
- Window Management*
  
  - Handy shortcuts for splitting windows, resizing panes, and reshuffling the layout in a minimal keystroke setup.
  - A handcrafted =toggle-centered-buffer= function focuses content by placing the active buffer in the center, hiding distractions in other windows.

** Custom Functions

- Handcrafted Lisp Utilities: A small collection of reusable functions that enhance workflow directly without accessing external configuration files or plugins:
  - =toggle-centered-buffer=: Dynamically rebalances the window layout for distraction-free working.
  - =my/dired-duplicate-file=: Quickly duplicates the currently selected file in dired mode, increasing workflow efficiency for file templating.
  - =my/copy-buffer-to-kill-ring=: Copies the entirety of the current buffer content directly to the kill ring for seamless external clipboard usage.

** No External Packages Required

- No Dependency on ELPA/MELPA: This configuration deliberately avoids using 3rd-party packages, ensuring it remains lightweight and portable across systems. All enhancements and ergonomic tweaks leverage built-in Emacs capabilities and Emacs Lisp.
- Offline-First Design: With no dependency on online repositories or external tools, this setup works out of the box even in restricted or air-gapped environments.

** Additional Ergonomic Setup

- Cross-Platform Key Remapping: Accompanying the Emacs configuration directory are external scripts to enforce ergonomic system-wide keybindings for more efficient Emacs usage:

*** *Windows / wowee*:
    
Note that this is present as a submodule leveraging https://github.com/captainflasmr/wowee which are AutoHotKey scripts that allow easy key remapping and also Emacs type key commands across Windows.

The idea here is that the keys are mapped through AutoHotKey and then Sticky Keys are natively enable to give a nice ergonomic experience through Emacs.

**** Remappings

- CapsLock â†’ Ctrl
- Right Alt â†’ Ctrl
- Sticky Keys natively enabled

**** Instructions for use

1. **Install AutoHotKey**: Download and install AutoHotKey from [AutoHotKey's official website](https://www.autohotkey.com/).
2. **Run WOWEE**: Double-click on the `wowee.ahk` script to start WOWEE. Once running, Emacs commands will be available in your Windows environment.
3. **Quit WOWEE**: To quit WOWEE, right-click the AutoHotKey icon in the task tray and select "Exit."
    
*** *Linux (X11/Wayland)*:
    
Includes custom *xkb* configuration files to enable similar ergonomic key remappings:

**** Remappings

- CapsLock â†’ Ctrl
- Right Alt â†’ Ctrl
- Sticky Keys

**** Instructions for use

#+begin_src bash :tangle no
xkbcomp keymap_with_sticky_modifiers.xkb $DISPLAY
#+end_src

** Portable Directory Structure

- A self-contained folder structure that encapsulates all necessary files:
  
  #+begin_src bash :tangle no 
emacs-core/
â”œâ”€â”€ emacs-core.org                   # Main Emacs literate configuration file
â”œâ”€â”€ init.el                          # Main Emacs configuration file
â”œâ”€â”€ keymap_with_sticky_modifiers.xkb # linux key configuration for ergonomic key remapping
â”œâ”€â”€ wowee/                           # Windows autohotkey scripts for ergonomic key remapping
â””â”€â”€ README.org                       # Setup guide and readme
  #+end_src
  
This directory can be zipped, copied, and unpacked on any machine to instantly set up a usable, ergonomic Emacs environment.

* Setup

- Clone the repository:

  #+begin_src bash :tangle no
git clone https://github.com/captainflasmr/Emacs-core ~/.emacs.d.core
  #+end_src


- Symlink the init file:

  #+begin_src bash :tangle no
ln -s ~/.emacs.d.core/init.el ~/.emacs.d/init.el
  #+end_src

OR

- Define startup directory

  emacs --init-directory=~/.emacs.d.core

- Launch Emacs:

  #+begin_src bash :tangle no
emacs
  #+end_src

- Optional: Customize the paths and keybindings in the **init.el** file to better fit your workflow.

* Roadmap                                                           :roadmap:

For features that will be (hopefully) converted to core see https://github.com/captainflasmr/Emacs-enhanced

* Testing

Created an =emacs-core.desktop= file containing the following:

#+begin_src fundamental-mode :tangle no 
[Desktop Entry]
Name=Emacs Core
GenericName=Text Editor
Comment=Edit text
MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
Exec=emacs --init-directory=~/.emacs.d.core
Icon=emacs
Type=Application
Terminal=false
Categories=Development;TextEditor;
StartupNotify=true
StartupWMClass=Emacs
Keywords=emacs;
Actions=new-window;new-instance;

[Desktop Action new-window]
Name=New Window
Exec=emacs --init-directory=~/.emacs.d.core

[Desktop Action new-instance]
Name=New Instance
Exec=emacs --init-directory=~/.emacs.d.core %F
#+end_src

and run the basic core Emacs config and test the new features

* requires-core

Ensures essential packages like `org`, `dired-x`, and `org-agenda` are loaded at startup.

#+begin_src elisp
;;
;; -> requires-core
;;
(require 'org)
(require 'grep)
(require 'bookmark)
(require 'dired)
#+end_src

* completion-core

Simple abbrev completion

#+begin_src elisp
;;
;; -> completion-core
;;
(setq-default abbrev-mode t)
(setq hippie-expand-try-functions-list
      '(try-complete-file-name-partially
        try-complete-file-name
        try-expand-all-abbrevs try-expand-dabbrev
        try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill
        try-complete-lisp-symbol-partially try-complete-lisp-symbol))
;; TAB cycle if there are only few candidates
(setq completion-cycle-threshold 3)
;; Enable indentation+completion using the TAB key.
;; `completion-at-point' is often bound to M-TAB.
(setq tab-always-indent 'complete)
#+end_src

* modeline-completion-core

Setup for both vanilla modeline.

#+begin_src elisp
;;
;; -> modeline-completion-core
;;
(fido-mode 1)
(define-key icomplete-minibuffer-map (kbd "M-RET") 'my-icomplete-exit-minibuffer-with-input)
(setq icomplete-compute-delay 0)
(setq icomplete-show-matches-on-no-input t)
#+end_src

* keys-navigation-core

Defines custom keybindings for navigating through files and Emacs features like tabs, dired, and scratch buffers.

#+begin_src elisp
;;
;; -> keys-navigation-core
;;
(defvar my-jump-keymap (make-sparse-keymap))
(global-set-key (kbd "M-o") my-jump-keymap)
(define-key my-jump-keymap (kbd "=") #'tab-bar-new-tab)
(define-key my-jump-keymap (kbd "b") (lambda () (interactive) (find-file "~/bin")))
(define-key my-jump-keymap (kbd "e")
            (lambda ()
              (interactive)
              (find-file (expand-file-name "init.el" user-emacs-directory))))
(define-key my-jump-keymap (kbd "f") #'my/find-file)
(define-key my-jump-keymap (kbd "g") (lambda () (interactive) (find-file "~/.config")))
(define-key my-jump-keymap (kbd "h") (lambda () (interactive) (find-file "~")))
(define-key my-jump-keymap (kbd "j") (lambda () (interactive) (find-file "~/DCIM/content/aaa--todo.org")))
(define-key my-jump-keymap (kbd "k")
            (lambda () (interactive)
              (find-file (concat user-emacs-directory "emacs--core.org"))))
(define-key my-jump-keymap (kbd "l") #'my/recentf-open)
(define-key my-jump-keymap (kbd "m") #'customize-themes)
(define-key my-jump-keymap (kbd "o") #'bookmark-jump)
(define-key my-jump-keymap (kbd "r") (lambda () (interactive) (switch-to-buffer "*scratch*")))
(define-key my-jump-keymap (kbd "w") (lambda () (interactive) (find-file "~/DCIM/content/")))
(define-key my-jump-keymap (kbd "-") #'tab-close)
;;
(global-set-key (kbd "M-a") #'my/quick-window-jump)

#+end_src

* hooks-core

Any functions that are run being associated with a mode.

#+begin_src elisp
;;
;; -> keys-visual-core
;;
(add-hook 'text-mode-hook 'visual-line-mode)
#+end_src

* keys-visual-core

Sets up keybindings for quickly toggling visual features like font, theme, line numbers, and other window displays.

#+begin_src elisp
;;
;; -> keys-visual-core
;;
(defvar my-win-keymap (make-sparse-keymap))
(global-set-key (kbd "C-q") my-win-keymap)
(define-key my-win-keymap (kbd "c") #'display-fill-column-indicator-mode)
(define-key my-win-keymap (kbd "d") #'window-divider-mode)
(define-key my-win-keymap (kbd "e") #'whitespace-mode)
(define-key my-win-keymap (kbd "f") #'font-lock-mode)
(define-key my-win-keymap (kbd "h") #'global-hl-line-mode)
(define-key my-win-keymap (kbd "k") #'my/toggle-mode-line)
(define-key my-win-keymap (kbd "l") #'my/sync-tab-bar-to-theme)
(define-key my-win-keymap (kbd "m") #'my/load-theme)
(define-key my-win-keymap (kbd "n") #'display-line-numbers-mode)
(define-key my-win-keymap (kbd "o") #'toggle-centered-buffer)
(define-key my-win-keymap (kbd "p") #'variable-pitch-mode)
(define-key my-win-keymap (kbd "q") #'toggle-menu-bar-mode-from-frame)
(define-key my-win-keymap (kbd "s") #'my/toggle-internal-border-width)
(define-key my-win-keymap (kbd "u") #'set-cursor-color)
(define-key my-win-keymap (kbd "v") #'visual-line-mode)
(define-key my-win-keymap (kbd "b") #'(lambda () (interactive)(tab-bar-mode 'toggle)))
#+end_src

* keys-other-core

Configures a sparse keymap for miscellaneous actions like evaluating expressions and capturing content with Org mode.

#+begin_src elisp
;;
;; -> keys-other-core
;;
(global-set-key (kbd "M-s ,") #'my/mark-line)
(global-set-key (kbd "M-s =") #'ediff-buffers)
(global-set-key (kbd "M-s g") #'my/grep)
(global-set-key (kbd "M-s h") #'my/mark-block)
(global-set-key (kbd "M-s j") #'eval-defun)
(global-set-key (kbd "M-s l") #'eval-expression)
(global-set-key (kbd "M-s x") #'diff-buffer-with-file)
(global-set-key (kbd "M-s w") #'(lambda ()(interactive)
                                  (org-html-export-to-html)
                                  (my/html-promote-headers)
                                  (my/html-org-table-highlight)))
(global-set-key (kbd "M-s e") #'(lambda ()(interactive)
                                  (org-odt-export-to-odt)
                                  (async-shell-command
                                   "libreoffice --headless --convert-to docx confluence--setup-sles.odt" "*create-docs*")))
(global-set-key (kbd "M-s ;") #'my/copy-buffer-to-kill-ring)
#+end_src

* keybinding-core

Demonstrates a broad set of global keybindings for common actions like saving buffers, controlling text scale, and navigating large documents.

#+begin_src elisp
;;
;; -> keybinding-core
;;
(global-set-key (kbd "C--") (lambda ()(interactive)(text-scale-adjust -1)))
(global-set-key (kbd "C-=") (lambda ()(interactive)(text-scale-adjust 1)))
(global-set-key (kbd "C-c ,") 'find-file-at-point)
(global-set-key (kbd "C-c a") #'org-agenda)
(global-set-key (kbd "C-c c") #'org-capture)
(global-set-key (kbd "C-c h") #'my/shell-create)
(global-set-key (kbd "C-c j") #'my/repeat-window-size)
(global-set-key (kbd "C-c o h") #'outline-hide-sublevels)
(global-set-key (kbd "C-c o s") #'outline-show-all)
(global-set-key (kbd "C-x ;") #'my/switch-to-thing)
(global-set-key (kbd "C-x C-b") 'ibuffer)
(global-set-key (kbd "C-x [") #'beginning-of-buffer)
(global-set-key (kbd "C-x ]") #'end-of-buffer)
(global-set-key (kbd "C-x j") #'(lambda() (interactive)(tab-bar-history-back)(my/repeat-history)))
(global-set-key (kbd "C-x k") #'(lambda() (interactive)(tab-bar-history-forward)(my/repeat-history)))
(global-set-key (kbd "C-x l") #'scroll-lock-mode)
(global-set-key (kbd "C-x m") #'my/switch-to-thing)
(global-set-key (kbd "C-x s") #'save-buffer)
(global-set-key (kbd "C-x v e") 'vc-ediff)
(global-set-key (kbd "C-x x g") #'revert-buffer)
(global-set-key (kbd "C-x x t") #'toggle-truncate-lines)
(global-set-key (kbd "C-z") #'my/comment-or-uncomment)
(global-set-key (kbd "M-'") #'set-mark-command)
(global-set-key (kbd "M-0") 'delete-window)
(global-set-key (kbd "M-1") #'delete-other-windows)
(global-set-key (kbd "M-2") #'split-window-vertically)
(global-set-key (kbd "M-3") #'split-window-horizontally)
(global-set-key (kbd "M-9") #'hippie-expand)
(global-set-key (kbd "M-;") 'delete-other-windows)
(global-set-key (kbd "M-[") #'yank)
(global-set-key (kbd "M-]") #'yank-pop)
(global-set-key (kbd "M-c") #'delete-other-windows)
(global-set-key (kbd "M-e") #'dired-jump)
(global-set-key (kbd "M-g i") 'imenu)
(global-set-key (kbd "M-i") #'tab-bar-switch-to-next-tab)
(global-set-key (kbd "M-j") #'(lambda ()(interactive)(scroll-up (/ (window-height) 4))))
(global-set-key (kbd "M-k") #'(lambda ()(interactive)(scroll-down (/ (window-height) 4))))
(global-set-key (kbd "M-l") #'split-window-horizontally)
(global-set-key (kbd "M-m") #'split-window-vertically)
(global-set-key (kbd "M-u") #'tab-bar-switch-to-prev-tab)
(global-set-key (kbd "M-z") #'my/comment-or-uncomment)
(global-unset-key (kbd "C-h h"))
(global-unset-key (kbd "C-t"))
(with-eval-after-load 'vc-dir
  (define-key vc-dir-mode-map (kbd "e") #'vc-ediff))
#+end_src

* modes-core

Turns on various modes like `global-font-lock-mode` for syntax highlighting and `show-paren-mode` for matching parenthesis visualization, and configures preferences for a wide array of basic behaviours and visual indicators.

#+begin_src elisp
;;
;; -> modes-core
;;
(column-number-mode 1)
(desktop-save-mode -1)
(display-time-mode -1)
(global-auto-revert-mode t)
(savehist-mode 1)
(show-paren-mode t)
(tab-bar-history-mode 1)
(global-font-lock-mode t)
#+end_src

* bell-core

Suppresses the auditory bell function in Emacs and opts for a visible bell or completely ignores bell triggers, improving the user interface experience during invalid operations.

#+begin_src elisp
;;
;; -> bell-core
;;
(setq visible-bell t)
(setq ring-bell-function 'ignore)
#+end_src

* setqs-core

This broad category includes a wide range of `setq` configurations that modify the behaviour of Emacs's core features â€” from file handling to search behaviours, reinforcing the customizability of Emacs.

#+begin_src elisp
;;
;; -> setqs-core
;;
(setq completion-styles '(basic partial-completion emacs22))
(setq custom-safe-themes t)
(setq delete-selection-mode nil)
(setq enable-local-variables :all)
(setq frame-title-format "%f")
(setq kill-whole-line t)
(setq-default truncate-lines t)
(setq frame-inhibit-implied-resize t)
(setq native-comp-async-report-warnings-errors nil)
#+end_src

* confirm-core

Configures aliases and settings for reducing the need for confirmations in repetitive tasks, streamlining user workflows.

#+begin_src elisp
;;
;; -> confirm-core
;;
(defalias 'yes-or-no-p 'y-or-n-p)
(setq confirm-kill-emacs 'y-or-n-p)
(setq confirm-kill-processes nil)
(setq confirm-nonexistent-file-or-buffer nil)
(set-buffer-modified-p nil)
#+end_src

* backups-core

Adjusts Emacs's file backup settings for a better experience, specifying backup file locations and policies to prevent data loss while keeping the working directory clean.

#+begin_src elisp
;;
;; -> backups-core
;;
(setq make-backup-files 1)
(setq backup-directory-alist '(("." . "~/backup"))
      backup-by-copying t    ; Don't delink hardlinks
      version-control t      ; Use version numbers on backups
      delete-old-versions t  ; Automatically delete excess backups
      kept-new-versions 10   ; how many of the newest versions to keep
      kept-old-versions 5)   ; and how many of the old
#+end_src

* custom-settings-core

Places for `custom-set-variables` and `custom-set-faces` used by Emacs's customization system to record user preferences set through the graphical customize interface.

#+begin_src elisp
;;
;; -> custom-settings-core
;;
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(org-level-1 ((t (:inherit default :weight regular :height 1.0))))
 '(org-level-2 ((t (:inherit default :weight light :height 1.0))))
 '(org-level-3 ((t (:inherit default :weight light :height 1.0))))
 '(org-level-4 ((t (:inherit default :weight light :height 1.0))))
 '(org-level-5 ((t (:inherit default :weight light :height 1.0))))
 '(org-level-6 ((t (:inherit default :weight light :height 1.0))))
 '(ediff-current-diff-A ((t (:extend t :background "#b5daeb" :foreground "#000000"))))
 '(ediff-even-diff-A ((t (:background "#bafbba" :foreground "#000000" :extend t))))
 '(ediff-fine-diff-A ((t (:background "#f4bd92" :foreground "#000000" :extend t))))
 '(ediff-odd-diff-A ((t (:background "#b8fbb8" :foreground "#000000" :extend t))))
 '(font-lock-warning-face ((t (:foreground "#930000" :inverse-video nil))))
 '(org-link ((t (:underline nil))))
 '(indent-guide-face ((t (:background "#282828" :foreground "#666666"))))
 '(widget-button ((t (:inherit fixed-pitch :weight regular))))
 '(window-divider ((t (:foreground "black"))))
 '(org-tag ((t (:height 0.99))))
 '(vertical-border ((t (:foreground "#000000")))))
;;
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(custom-enabled-themes '(wombat))
 '(warning-suppress-log-types '((frameset)))
 '(warning-suppress-types '((frameset))))
#+end_src

* defun-core

Defines a suite of custom functions to extend Emacs's functionality tailored to specific tasks or personal preferences, showcasing the extensibility of Emacs with Lisp programming.

#+begin_src elisp
;;
;; -> defun-core
;;
(defun save-macro (name)
  "Save a macro by NAME."
  (interactive "SName of the macro: ")
  (kmacro-name-last-macro name)
  (find-file user-init-file)
  (goto-char (point-max))
  (newline)
  (insert-kbd-macro name)
  (newline))
;;
(defun my/comment-or-uncomment ()
  "Comments or uncomments the current line or region."
  (interactive)
  (if (region-active-p)
      (comment-or-uncomment-region
       (region-beginning)(region-end))
    (comment-or-uncomment-region
     (line-beginning-position)(line-end-position))))
;;
(defun my/dired-duplicate-file (arg)
  "Duplicate a file from DIRED with an incremented number.
                                If ARG is provided, it sets the counter."
  (interactive "p")
  (let* ((file (dired-get-file-for-visit))
         (dir (file-name-directory file))
         (name (file-name-nondirectory file))
         (base-name (file-name-sans-extension name))
         (extension (file-name-extension name t))
         (counter (if arg (prefix-numeric-value arg) 1))
         (new-file))
    (while (and (setq new-file
                      (format "%s%s_%03d%s" dir base-name counter extension))
                (file-exists-p new-file))
      (setq counter (1+ counter)))
    (if (file-directory-p file)
        (copy-directory file new-file)
      (copy-file file new-file))
    (dired-revert)))
;;
(defun my/mark-line ()
  "Mark whole line."
  (interactive)
  (beginning-of-line)
  (push-mark (point) nil t)
  (end-of-line))
;;
(defun my/mark-block ()
  "Marking a block of text surrounded by a newline."
  (interactive)
  (when (not (region-active-p))
    (backward-char))
  (skip-chars-forward " \n\t")
  (re-search-backward "^[ \t]*\n" nil 1)
  (skip-chars-forward " \n\t")
  (when (not (region-active-p))
    (push-mark))
  (re-search-forward "^[ \t]*\n" nil 1)
  (skip-chars-backward " \n\t")
  (setq mark-active t))
;;
(defun my/repeat-history ()
  ""
  (interactive)
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "j") (lambda () (interactive)
                                (tab-bar-history-back)))
    (define-key map (kbd "k") (lambda () (interactive)
                                (tab-bar-history-forward)))
    (set-transient-map map t)))
;;
(defun my/get-window-position ()
  "Return the position of the current window as 'left', 'right', 'top', or 'bottom'."
  (let* ((edges (window-edges))
         (min-x (nth 0 edges))
         (min-y (nth 1 edges))
         (max-x (nth 2 edges))
         (max-y (nth 3 edges))
         (frame-width (frame-width))
         (frame-height (frame-height)))
    (cond
     ((<= min-x 0) 'left)
     ((>= max-x frame-width) 'right)
     ((= min-y 0) 'top)
     ((= max-y frame-height) 'bottom)
     (t 'center))))
;;
(defun my/adaptive-resize (horizontal delta)
  "Resize the current window adaptively based on its position.
HORIZONTAL is non-nil for horizontal resizing (left/right).
DELTA is the amount to resize (positive to grow, negative to shrink)."
  (let ((pos (my/get-window-position)))
    (cond
     ((and horizontal (eq pos 'left)) (enlarge-window (- delta) t))
     ((and horizontal (eq pos 'right)) (enlarge-window delta t))
     ((and (not horizontal) (eq pos 'top)) (enlarge-window delta nil))
     ((and (not horizontal) (eq pos 'bottom)) (enlarge-window (- delta) nil))
     (t (enlarge-window delta horizontal)))))
;;
(defun my/repeat-window-size ()
  "Set up a sparse keymap for repeating window actions with adaptive resizing."
  (interactive)
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "n") (lambda () (interactive)
                                (window-swap-states)))
    (define-key map (kbd "h") (lambda () (interactive)
                                (my/adaptive-resize t 2)))
    (define-key map (kbd "l") (lambda () (interactive)
                                (my/adaptive-resize t -2)))
    (define-key map (kbd "j") (lambda () (interactive)
                                (my/adaptive-resize nil 1)))
    (define-key map (kbd "k") (lambda () (interactive)
                                (my/adaptive-resize nil -1)))
    (set-transient-map map t)))
;;
(defun my/dired-du ()
  "Run 'du -hc' and count the total number of files in the directory under
  the cursor in Dired, then display the output in a buffer named *dired-du*."
  (interactive)
  (let ((current-dir (dired-get-file-for-visit)))
    (if (file-directory-p current-dir)
        (let ((output-buffer-name "*dired-du*"))
          (with-current-buffer (get-buffer-create output-buffer-name)
            (erase-buffer)) ; Clear the buffer before running the command
          (async-shell-command
           (format "du -hc --max-depth=1 %s && echo && echo 'File counts per subdirectory:' && find %s -maxdepth 2 -type d -exec sh -c 'echo -n \"{}: \"; find \"{}\" -type f | wc -l' \\;"
                   (shell-quote-argument current-dir)
                   (shell-quote-argument current-dir))
           output-buffer-name))
      (message "The current point is not a directory."))))
;;
(defun darken-color (color percent)
  "Return a darker shade of COLOR by reducing its brightness by PERCENT."
  (let* ((rgb (color-values color))
         (factor (/ (- 100 percent) 100.0))
         (darker-rgb (mapcar (lambda (x) (max 0 (round (* x factor)))) rgb)))
    (apply 'format "#%02x%02x%02x" (mapcar (lambda (x) (/ x 256)) darker-rgb))))
;;
(defun set-hl-line-darker-background ()
  "Set the hl-line background to a slightly darker shade of the default background,
                                            preserving the original foreground colors of the current line."
  (interactive)
  (require 'hl-line)
  (unless global-hl-line-mode
    (global-hl-line-mode 1))
  (when (facep 'hl-line)
    (let* ((bg (face-background 'default))
           (darker-bg (darken-color bg 15)))
      (custom-set-faces
       `(hl-line ((t (:background ,darker-bg))))))))
;;
(defun my/load-theme ()
  "Prompt to select a theme from available themes and load the selected theme."
  (interactive)
  (let ((theme (completing-read "Choose theme: " (mapcar 'symbol-name (custom-available-themes)))))
    (dolist (item custom-enabled-themes)
      (disable-theme item))
    (load-theme (intern theme) t)))
;;
(defun my/switch-to-thing ()
  "Switch to a buffer, open a recent file, jump to a bookmark,
                                        or change the theme from a unified interface."
  (interactive)
  (let* ((buffers (mapcar #'buffer-name (buffer-list)))
         (recent-files recentf-list)
         (bookmarks (bookmark-all-names))
         (all-options (append buffers recent-files bookmarks))
         (selection (completing-read "Switch to: " all-options)))
    (pcase selection
      ((pred (lambda (sel) (member sel buffers))) (switch-to-buffer selection))
      ((pred (lambda (sel) (member sel bookmarks))) (bookmark-jump selection))
      (_ (find-file selection)))))
;;
(defvar highlight-rules
  '((th . (("TODO" . "#999")))
    (td . (("\\&gt" . "#bbb")
           ("-\\&gt" . "#ccc")
           ("- " . "#ddd")
           ("- - - - " . "#eee")
           ("- - - - - - - - " . "#fff")
           ("TODO" . "#fdd")
           ("DOING" . "#ddf")
           ("DONE" . "#dfd"))))
  "Alist of elements ('th or 'td) and associated keywords/colors for row highlighting.")
;;
(defun apply-row-style (row-start row-attributes color)
  "Apply a background COLOR to the row starting at ROW-START with ROW-ATTRIBUTES."
  (goto-char row-start)
  (kill-line)
  (insert (format "<tr%s style=\"background: %s\">\n" row-attributes color)))
;;
(defun highlight-row-by-rules (row-start row-end row-attributes element)
  "Highlight a row based on ELEMENT ('th or 'td) keyword rules within ROW-START to ROW-END."
  (let ((rules (cdr (assoc element highlight-rules))))
    (dolist (rule rules)
      (let ((keyword (car rule))
            (color (cdr rule)))
        (when (save-excursion
                (and (re-search-forward (format "<%s.*>%s.*</%s>" element keyword element) row-end t)
                     (goto-char row-start)))
          (apply-row-style row-start row-attributes color))))))
;;
(defun my/html-org-table-highlight ()
  "Open the exported HTML file, find tables with specific classes,
                                                        and add background styles to rows containing keywords in <td> or <th> elements."
  (interactive)
  (let* ((org-file (buffer-file-name))
         (html-file (concat (file-name-sans-extension org-file) ".html")))
    (with-temp-buffer
      (insert-file-contents html-file)
      (goto-char (point-min))
      (while (re-search-forward "<table.*>" nil t)
        (let ((table-start (point))
              (table-end (save-excursion
                           (when (re-search-forward "</table>" nil t)
                             (point)))))
          (when table-end
            (save-restriction
              (narrow-to-region table-start table-end)
              (goto-char (point-min))
              (while (re-search-forward "<tr\\(.*\\)>" nil t)
                (let ((row-start (match-beginning 0))
                      (row-attributes (match-string 1))
                      (row-end (save-excursion (search-forward "</tr>"))))
                  (highlight-row-by-rules row-start row-end row-attributes 'th)
                  (highlight-row-by-rules row-start row-end row-attributes 'td)))))))
      (write-region (point-min) (point-max) html-file))))
;;
(defun my/format-to-table (&optional match properties-to-display)
  "Format Org headings into a structured alist, optionally filtered by MATCH
  and displaying only specified PROPERTIES-TO-DISPLAY (e.g., '(\"ID\" \"PRIORITY\"))."
  (interactive)
  (let ((rows '())
        (header '("TODO" "Tags" "Title" "Comments")) ;; Start without "Properties"
        (max-level 0))
    (save-excursion
      (goto-char (point-min))
      (when match (re-search-forward (format "\\*%s\\*$" (regexp-quote match)) nil t))
      ;; Add property names to the header dynamically
      (setq header (append header properties-to-display))
      (org-map-entries
       (lambda ()
         (let* ((entry (org-element-at-point))
                (heading (org-get-heading t t t t))
                (level (org-outline-level))
                (tags (remove "noexport" (org-get-tags)))
                (todo (org-get-todo-state))
                (vis-indent "- ")
                (contents "")
                (all-properties (org-entry-properties))
                (filtered-properties
                 (mapcar (lambda (prop)
                           (if (cdr (assoc prop all-properties))
                               (cdr (assoc prop all-properties))
                             ""))
                         properties-to-display)))
           (prin1 properties-to-display)
           (prin1 all-properties)
           (prin1 filtered-properties)
           (org-end-of-meta-data nil)
           (skip-chars-forward " \n\t")
           (when (eq (org-element-type (org-element-at-point)) 'paragraph)
             (let ((start (point)))
               (org-next-visible-heading 1)
               (setq contents (buffer-substring-no-properties start (point)))
               (dolist (pattern '("^#\\+begin.*" "^#\\+end.*" "\n+"))
                 (setq contents (replace-regexp-in-string pattern
                                                          (if (string= pattern "\n+") " " "")
                                                          (string-trim contents))))))
           (setq max-level (max max-level level))
           (push (append
                  (list
                   (or todo "")
                   (string-join tags ":")
                   (cond ((= level 1)
                          (concat "> " heading))
                         ((= level 2)
                          (concat "> " heading))
                         ((= level 3)
                          (concat "*> " heading "*"))
                         ((= level 4)
                          (concat "*" heading "*"))
                         (t
                          (concat "/"
                                  (mapconcat (lambda (_) vis-indent)
                                             (make-list (* (- level 4) 1) "") "") heading "/")))
                   (or contents ""))
                  filtered-properties)
                 rows)))
       nil (when match 'tree)))
    (setq rows (reverse rows))
    (push 'hline rows)
    (cons header rows)))
;;
(defun my/html-promote-headers ()
  "Promote all headers in the HTML file by one level (e.g., h2 -> h1, h3 -> h2, etc.), accounting for attributes."
  (interactive)
  (let* ((org-file (buffer-file-name))
         (html-file (concat (file-name-sans-extension org-file) ".html")))
    (with-temp-buffer
      (insert-file-contents html-file)
      (goto-char (point-min))
      (let ((header-levels '("h1" "h2" "h3" "h4" "h5" "h6")))
        (dolist (level header-levels)
          (let* ((current-level (string-to-number (substring level 1)))
                 (new-level (max 1 (1- current-level)))  ;; Promote but don't go below h1
                 (open-tag-regex (format "<%s\\([^>]*\\)>" level))  ;; Regex for opening tag with attributes
                 (close-tag-regex (format "</%s>" level))  ;; Regex for closing tag
                 (new-open-tag (format "<h%d\\1>" new-level))  ;; Replacement for opening tag, preserving attributes
                 (new-close-tag (format "</h%d>" new-level)))  ;; Replacement for closing tag
            ;; Replace opening tags
            (goto-char (point-min))
            (while (re-search-forward open-tag-regex nil t)
              (replace-match new-open-tag))
            ;; Replace closing tags
            (goto-char (point-min))
            (while (re-search-forward close-tag-regex nil t)
              (replace-match new-close-tag)))))
      (write-region (point-min) (point-max) html-file))))
;;
(defun my/copy-buffer-to-kill-ring ()
  "Copy the entire buffer to the kill ring without changing the point."
  (interactive)
  (kill-ring-save (point-min) (point-max))
  (message (concat (buffer-file-name) " Copied")))
;;
(defun my/sync-tab-bar-to-theme (&optional color)
  "Synchronize tab-bar faces with the current theme, and set
mode-line background color interactively using `read-color`
if COLOR is not provided as an argument."
  (interactive (list (when current-prefix-arg (read-color "Color: "))))
  ;; Determine the color to use
  (let ((selected-color (or color (read-color "Select mode-line background color: "))))
    (set-hl-line-darker-background)
    (set-face-attribute 'mode-line nil :height 120 :underline nil :overline nil :box nil
                        :background selected-color :foreground "#000000")
    (set-face-attribute 'mode-line-inactive nil :height 120 :underline nil :overline nil
                        :background "#000000" :foreground "#aaaaaa")
    (let ((default-bg (face-background 'default))
          (default-fg (face-foreground 'default))
          (default-hl (face-background 'highlight))
          (inactive-fg (face-foreground 'mode-line-inactive)))
      (custom-set-faces
       `(vertical-border ((t (:foreground ,(darken-color default-fg 60)))))
       `(window-divider ((t (:foreground ,(darken-color default-fg 60)))))
       `(fringe ((t (:foreground ,default-bg :background ,default-bg))))
       `(tab-bar ((t (:inherit default :background ,default-bg :foreground ,default-fg))))
       `(tab-bar-tab ((t (:inherit 'highlight :background ,selected-color :foreground "#000000"))))
       `(tab-bar-tab-inactive ((t (:inherit default :background ,default-bg :foreground ,inactive-fg
                                            :box (:line-width 2 :color ,default-bg :style released-button)))))))))
(my/sync-tab-bar-to-theme "#ff4444")
;;
(defun my/dired-file-to-org-link ()
  "Transform the file path under the cursor in Dired to an Org mode
  link and copy to kill ring.
  This function transforms the current file path in Dired mode into
  an Org link with attributes for both org-mode and HTML width
  settings. The generated link is then copied to the kill ring for
  easy pasting."
  (interactive)
  (let ((file-path (dired-get-file-for-visit)))
    (if file-path
        (let* ((relative-path (file-relative-name file-path
                                                  (project-root-safe)))
               (org-link (concat "#+attr_org: :width 300px\n"
                                 "#+attr_html: :width 100%\n"
                                 "[[file:" relative-path "]]\n")))
          (kill-new org-link)
          (message "Copied to kill ring: %s" org-link))
      (message "No file under the cursor"))))
#+end_src

* window-positioning-core

Configures rules and behaviours for display-buffer functions to control how new buffers are shown, whether in existing windows or new splits, enhancing window management in Emacs.

#+begin_src elisp
;;
;; -> window-positioning-core
;;
(add-to-list 'display-buffer-alist
             '("\\*.*shell"
               (display-buffer-reuse-window display-buffer-in-direction)
               (direction . bottommost)
               (dedicated . t)
               (window-height . 0.2)
               (inhibit-same-window . t)))
(add-to-list 'display-buffer-alist
             '("\\*grep"
               (display-buffer-reuse-window display-buffer-in-direction)
               (direction . leftmost)
               (dedicated . t)
               (window-width . 0.4)
               (inhibit-same-window . t)))
(add-to-list 'display-buffer-alist
             '("\\*compilation"
               (display-buffer-reuse-window display-buffer-in-direction)
               (direction . leftmost)
               (dedicated . t)
               (window-width . 0.3)
               (inhibit-same-window . t)))
(add-to-list 'display-buffer-alist
             '("\\*Help\\*"
               (display-buffer-reuse-window display-buffer-same-window)))
(add-to-list 'display-buffer-alist
             '("\\*Async" display-buffer-no-window
               (allow-no-window . t)))
(add-to-list 'display-buffer-alist
             '("\\*Messages" display-buffer-same-window))
#+end_src

* org-core

Extends and customizes Org mode for document structuring, note-taking, and project management, highlighting customization options for exporting, appearance, and functionality enhancements.

#+begin_src elisp
;;
;; -> org-core
;;
(setq org-src-preserve-indentation t)
(setq org-edit-src-content-indentation 0)
(setq org-tags-sort-function 'org-string-collate-greaterp)
(setq org-startup-indented t)
(setq org-use-speed-commands t)
(setq org-hide-leading-stars t)
(setq org-todo-keywords
      '((sequence "TODO" "DOING" "|" "DONE" "CANCELLED"))
      org-todo-keyword-faces
      '(("TODO" . "#ee5566")
        ("DOING" . "#5577aa")
        ("DONE" . "#77aa66")
        ("CANCELLED" . "#426b3e")))
#+end_src

* org-agenda-core

Customizes the Org Agenda for a personalized task management and calendar view, adjusting settings for diary integration and custom agenda views to fit specific planning needs.

#+begin_src elisp
;;
;; -> org-agenda-core
;;
(with-eval-after-load 'org-agenda
  (setq org-agenda-include-diary nil)
  (setq org-agenda-show-all-dates t)
  (setq org-refile-targets '((org-agenda-files :maxlevel . 1)))
  (setq org-agenda-custom-commands
        '(("m" "Month View" agenda ""
           ((org-agenda-start-day "today")
            (org-agenda-span 30)
            (org-agenda-time-grid nil)))
          ("0" "Year View (2020)" agenda ""
           ((org-agenda-start-day "2020-01-01")
            (org-agenda-span 'year)
            (org-agenda-time-grid nil)))
          ("1" "Year View (2021)" agenda ""
           ((org-agenda-start-day "2021-01-01")
            (org-agenda-span 'year)
            (org-agenda-time-grid nil)))
          ("2" "Year View (2022)" agenda ""
           ((org-agenda-start-day "2022-01-01")
            (org-agenda-span 'year)
            (org-agenda-time-grid nil)))
          ("3" "Year View (2023)" agenda ""
           ((org-agenda-start-day "2023-01-01")
            (org-agenda-span 'year)
            (org-agenda-time-grid nil)))
          ("4" "Year View (2024)" agenda ""
           ((org-agenda-start-day "2024-01-01")
            (org-agenda-span 'year)
            (org-agenda-time-grid nil))))))
#+end_src

* scroll-core

Adjusts scrolling behaviours and settings for a smoother navigation experience within buffer contents.

#+begin_src elisp
;;
;; -> scroll-core
;;
(setq scroll-margin 10)
(setq scroll-conservatively 10)
(setq scroll-preserve-screen-position t)
#+end_src

* dired-core

Enhances Dired, the directory editor, with additional functionalities like async deletion, improving file management workflows within Emacs.

#+begin_src elisp
;;
;; -> dired-core
;;
(setq dired-dwim-target t)
(setq dired-listing-switches "-alGgh")
(setq dired-auto-revert-buffer t)
(setq dired-confirm-shell-command nil)
(setq dired-no-confirm t)
(setq dired-deletion-confirmer '(lambda (x) t))
(setq dired-recursive-deletes 'always)
(with-eval-after-load 'dired
  (define-key dired-mode-map (kbd "C-c d") 'my/dired-duplicate-file)
  (define-key dired-mode-map (kbd "C-c u") 'my/dired-du)
  (define-key dired-mode-map (kbd "C-c i") 'my/image-dired-sort)
  (define-key dired-mode-map (kbd "W") 'dired-do-async-shell-command)
  (define-key dired-mode-map (kbd "b") 'my/dired-file-to-org-link)
  (setq dired-guess-shell-alist-user
        '(("\\.\\(jpg\\|jpeg\\|png\\|gif\\|bmp\\)$" "gthumb")
          ("\\.\\(mp4\\|mkv\\|avi\\|mov\\|wmv\\|flv\\|mpg\\)$" "mpv")
          ("\\.\\(mp3\\|wav\\|ogg\\|\\)$" "mpv")
          ("\\.\\(kra\\)$" "org.kde.krita")
          ("\\.\\(odt\\|ods\\)$" "libreoffice")
          ("\\.\\(html\\|htm\\)$" "firefox")
          ("\\.\\(pdf\\|epub\\)$" "xournalpp")))
  (define-key dired-mode-map (kbd "_") #'dired-create-empty-file))
#+end_src

* visuals-core

Configures various visual aspects of Emacs, including menu bar, toolbar, and scroll bar visibility, as well as window transparency and edge padding for a cleaner and more focused editing environment.

#+begin_src elisp
;;
;; -> visuals-core
;;
(menu-bar-mode -1)
(scroll-bar-mode -1)
(tool-bar-mode -1)
(setq inhibit-startup-screen t)
(setq use-dialog-box nil)
(setq window-divider-default-bottom-width 2)
(setq window-divider-default-right-width 2)
(setq window-divider-default-places t)
(window-divider-mode -1)
(defvar my/internal-border-width 0 "Default internal border width for toggling.")
(modify-all-frames-parameters `((internal-border-width . ,my/internal-border-width)))
(set-fringe-mode '(20 . 20))
(setq bookmark-set-fringe-mark nil)
(setq bookmark-fringe-mark nil)
;;
(add-hook 'prog-mode-hook #'my/rainbow-mode)
(add-hook 'org-mode-hook #'my/rainbow-mode)
(add-hook 'conf-space-mode-hook #'my/rainbow-mode)
#+end_src

* imenu-core

Customizes the Imenu index-building functionality for improved navigation within structured documents or source code, demonstrating regex-based configurations for specific file types.

#+begin_src elisp
;;
;; -> imenu-core
;;
(defun my-imenu-create-index ()
  "Create an index using definitions starting with ';; ->'."
  (let ((index-alist '())
        (regex "^;;[[:space:]]->\\(.+\\)$"))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward regex nil t)
        (let ((name (s-trim (match-string 1)))
              (pos (match-beginning 0)))
          (push (cons name (set-marker (make-marker) pos)) index-alist))))
    (setq imenu--index-alist (sort
                              index-alist
                              (lambda (a b)
                                (string< (car a) (car b)))))))
;;
;; (setq imenu-create-index-function #'my-imenu-create-index)
;;
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (setq truncate-lines t)
            (setq imenu-sort-function 'imenu--sort-by-name)
            (setq imenu-generic-expression
                  '((nil "^;;[[:space:]]+-> \\(.*\\)$" 1)))
            (imenu-add-menubar-index)))
;;
(add-hook 'conf-space-mode-hook
          (lambda ()
            (setq imenu-sort-function 'imenu--sort-by-name)
            (setq imenu-generic-expression
                  '((nil "^#[[:space:]]+-> \\(.*\\)$" 1)))
            (imenu-add-menubar-index)))
#+end_src

* recentf-core

Optimizes the handling of recently opened files list, tweaking preferences for the number of items shown and integration points for quick access to recent files.

#+begin_src elisp
;;
;; -> recentf-core
;;
(recentf-mode 1)
(setq recentf-max-menu-items 200)
(setq recentf-max-saved-items 200)
#+end_src

* modeline-core

Customizes the modeline for displaying active modes, buffer names, or other context-sensitive information, improving the feedback and control available at a glance.

#+begin_src elisp
;;
;; -> modeline-core
;;
(setq my/mode-line-format
      (list
       '(:eval (if (and (buffer-file-name) (buffer-modified-p))
                   (propertize " * " 'face
                               '(:background "#ff0000" :foreground "#ffffff" :inherit bold)) ""))
       '(:eval
         (propertize (format "%s" (abbreviate-file-name default-directory)) 'face '(:inherit bold)))
       '(:eval
         (if (not (equal major-mode 'dired-mode))
             (propertize (format "%s " (buffer-name)))
           " "))
       'mode-line-position
       'mode-line-modes
       'mode-line-misc-info
       '(:eval (format " | Point: %d" (point)))))
;;
(setq-default mode-line-format my/mode-line-format)
;;
(defun my/toggle-mode-line ()
  "Toggle the visibility of the mode-line by checking its current state."
  (interactive)
  (if (eq mode-line-format nil)
      (progn
        (setq-default mode-line-format my/mode-line-format)
        (setq frame-title-format "%f"))
    (progn
      (setq-default mode-line-format nil)
      (setq frame-title-format mode-line-format)))
  (force-mode-line-update t))
#+end_src

* grep-core

My aim here is to make rgrep as similar to deadgrep as possible for easier switching back and forth between a more vanilla like emacs experience.

#+begin_src elisp
;;
;; -> grep-core
;;
(eval-after-load 'grep
  '(progn
     (dolist (dir '("nas" ".cache" "cache" "elpa" "chromium" ".local/share" "syncthing" ".mozilla" ".local/lib" "Games"))
       (push dir grep-find-ignored-directories))
     (dolist (file '(".cache" "*cache*" "*.iso" "*.xmp" "*.jpg" "*.mp4"))
       (push file grep-find-ignored-files))
     ))
#+end_src

* spelling-core

Configures spell checking tools and dictionaries, integrating external tools like `aspell` or `hunspell`, and interfaces for checking and correcting spelling within documents.

#+begin_src elisp
;;
;; -> spelling-core
;;
(setq ispell-local-dictionary "en_GB")
(setq ispell-program-name "hunspell")
(setq dictionary-default-dictionary "*")
(setq dictionary-server "dict.org")
(setq dictionary-use-single-buffer t)
(define-prefix-command 'my-spell-prefix-map)
(global-set-key (kbd "C-c s") 'my-spell-prefix-map)
(global-set-key (kbd "C-c s s") #'(lambda()(interactive)
                                    (flyspell-buffer)
                                    (call-interactively 'flyspell-mode)))
(global-set-key (kbd "C-c s d") #'dictionary-lookup-definition)
(global-set-key (kbd "C-0") #'ispell-word)
#+end_src

* gdb-core

Sets up GDB, the GNU Debugger, integration for debugging within Emacs, tweaking interface elements and keybindings for a more convenient debugging workflow.

#+begin_src elisp
;;
;; -> gdb-core
;;
(setq gdb-display-io-nopopup 1)
(setq gdb-many-windows t)
(global-set-key (kbd "<f9>") 'gud-break)
(global-set-key (kbd "<f10>") 'gud-next)
(global-set-key (kbd "<f11>") 'gud-step)
#+end_src

* compilation-core

Customizes the Compilation mode for handling output from external commands, adjusting styles, behaviours, and filtering for an improved feedback loop during code build or script execution.

#+begin_src elisp
;;
;; -> compilation-core
;;
(setq compilation-always-kill t)
(setq compilation-context-lines 3)
(setq compilation-scroll-output t)
;; ignore warnings
(setq compilation-skip-threshold 2)
(global-set-key (kbd "<f5>") 'my/project-compile)
#+end_src

* diff-core

Customizes the appearance and behaviour of diff and merge tools within Emacs, adjusting styles for better readability and control over version control diffs and conflict resolution.

#+begin_src elisp
;;
;; -> diff-core
;;
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(setq ediff-highlight-all-diffs t)
(setq ediff-split-window-function 'split-window-horizontally)
(add-hook 'ediff-prepare-buffer-hook #'outline-show-all)
(add-hook 'ediff-prepare-buffer-hook (lambda () (visual-line-mode -1)))
#+end_src

* project-core

Customizes Emacs's project management features for handling multiple projects, demonstrating configurations for project discovery, switching, and build command integration.

#+begin_src elisp
;;
;; -> project-core
;;
(defun project-root-safe ()
  "Return the project root or nil if unavailable."
  (if (fboundp 'project-root)
      ;; Use project-root if available (Emacs 29+)
      (when-let ((project (project-current)))
        (project-root project))
    ;; Compatibility for Emacs < 29
    (when-let ((project (project-current)))
      (cdr (project-roots project)))))
;;
(defun my/project-create-compilation-search-path ()
  "Populate the 'compilation-search-path' variable.
With directories under project root using find."
  (interactive)
  (let ((find-command
         (concat "find " (project-root-safe)
                 " \\( -path \\*/.local -o -path \\*/.config -o
 -path \\*/.svn -o -path \\*/.git -o -path \\*/nas \\) -prune -o
 -type d -print")))
    (setq compilation-search-path
          (split-string
           (shell-command-to-string find-command)
           "\n" t))))
;;
(setq project-vc-extra-root-markers '(".project"))
#+end_src

* indentation-core

Defining very specific indentation and highlight guides

#+begin_src elisp
;;
;; -> indentation-core
;;
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
#+end_src

* etags-core

Generation of etags to have an offline alternative to LSP, uses the following bash script:

#+begin_src bash :tangle no
#!/bin/bash
TAGF=$PWD/TAGS
rm -f "$TAGF"
for src in `find $PWD \( -path \*/.cache -o \
               -path \*/.gnupg -o \
               -path \*/.local -o \
               -path \*/.mozilla -o \
               -path \*/.thunderbird -o \
               -path \*/.wine -o \
               -path \*/Games -o \
               -path \*/cache -o \
               -path \*/chromium -o \
               -path \*/elpa -o \
               -path \*/nas -o \
               -path \*/syncthing -o \
               -path \*/Image-Line -o \
               -path \*/.cargo -o \
               -path \*/.git -o \
               -path \*/.svn -o \
               -path \*/.themes -o \
               -path \*/themes -o \
               -path \*/objs -o \
               -path \*/ArtRage \) \
               -prune -o -type f -print`;
do
    case "${src}" in
        ,*.ad[absm]|*.[CFHMSacfhlmpsty]|*.def|*.in[cs]|*.s[as]|*.src|*.cc|\
            ,*.hh|*.[chy]++|*.[ch]pp|*.[chy]xx|*.pdb|*.[ch]s|*.[Cc][Oo][Bb]|\
            ,*.[eh]rl|*.f90|*.for|*.java|*.[cem]l|*.clisp|*.lisp|*.[Ll][Ss][Pp]|\
            [Mm]akefile*|*.pas|*.[Pp][LlMm]|*.psw|*.lm|*.pc|*.prolog|*.oak|\
            ,*.p[sy]|*.sch|*.scheme|*.[Ss][Cc][Mm]|*.[Ss][Mm]|*.bib|*.cl[os]|\
            ,*.ltx|*.sty|*.TeX|*.tex|*.texi|*.texinfo|*.txi|*.x[bp]m|*.yy|\
            ,*.[Ss][Qq][Ll])
            etags --append "${src}" -o "$TAGF";
            echo ${src}
            ;;
        ,*)
            FTYPE=`file ${src}`;
            case "${FTYPE}" in
                ,*script*text*)
                    etags --append "${src}" -o "$TAGF";
                    echo ${src}
                    ;;
                ,*text*)
                    if head -n1 "${src}" | grep '^#!' >/dev/null 2>&1;
                    then
                        etags --append "${src}" -o "$TAGF";
                        echo ${src}
                    fi;
                    ;;
            esac;
            ;;
    esac;
done
echo
echo "Finished!"
echo
#+end_src

#+begin_src elisp
;;
;; -> etags-core
;;
;;
(defun my/etags-load ()
  "Load TAGS file from the first it can find up the directory stack."
  (interactive)
  (let ((my-tags-file (locate-dominating-file default-directory "TAGS")))
    (when my-tags-file
      (message "Loading tags file: %s" my-tags-file)
      (visit-tags-table my-tags-file))))
;;
(when (executable-find "my-generate-etags.sh")
  (defun my/etags-update ()
    "Call external bash script to generate new etags for all languages it can find."
    (interactive)
    (async-shell-command "my-generate-etags.sh" "*etags*")))
;;
(defun predicate-exclusion-p (dir)
  "exclusion of directories"
  (not
   (or
    (string-match "/home/jdyer/examples/CPPrograms/nil" dir)
    )))
;;
(defun my/generate-etags ()
  "Generate TAGS file for various source files in `default-directory` and its subdirectories."
  (interactive)
  (message "Getting file list...")
  (let ((all-files
         (append
          (directory-files-recursively default-directory "\\(?:\\.cpp$\\|\\.c$\\|\\.h$\\)" nil 'predicate-exclusion-p)
          (directory-files-recursively default-directory "\\(?:\\.cs$\\|\\.cs$\\)" nil 'predicate-exclusion-p)
          (directory-files-recursively default-directory "\\(?:\\.ads$\\|\\.adb$\\)" nil 'predicate-exclusion-p)))
        (tags-file-path (expand-file-name (concat default-directory "TAGS"))))
    (unless (file-directory-p default-directory)
      (error "Default directory does not exist: %s" default-directory))
    ;; Generate TAGS file
    (dolist (file all-files)
      (message file)
      (shell-command (format "etags --append \%s -o %s" file tags-file-path)))))
;; (global-set-key (kbd "C-x p l") 'my/etags-load)
;; (global-set-key (kbd "C-x p u") 'my/etags-update)
#+end_src

* shell-core

Demonstrates customizations for shell integration within Emacs, optimizing settings for shell modes, command history, and shorthand functions for frequent shell-related tasks.

#+begin_src elisp
;;
;; -> shell-core
;;
(defun my/shell-create (name)
  "Create a custom-named eshell buffer with NAME."
  (interactive "sName: ")
  (eshell 'new)
  (let ((new-buffer-name (concat "*eshell-" name "*")))
    (rename-buffer new-buffer-name t)))
#+end_src

* tab-bar-core

Details configurations for Emacs's tab bar, showcasing customizations for tab behaviour, appearance, and integration points for keyboard navigation and tab management.

#+begin_src elisp
;;
;; -> tab-bar-core
;;
(setq tab-bar-close-button-show nil)
(setq tab-bar-new-button-show nil)
(setq tab-bar-new-tab-to 'rightmost)
(setq tab-bar-close-button-show nil)
#+end_src

* windows-specific-core

Curates configurations specific to the Windows operating system, adjusting paths, fonts, and environment variables for optimal use of Emacs on Windows.

#+begin_src elisp
;;
;; -> windows-specific-core
;;
(when (eq system-type 'windows-nt)
  (setq home-dir "c:/users/jimbo")
  (let ((xPaths
         `(,(expand-file-name "~/bin")
           ,(expand-file-name "~/bin/PortableGit/bin")
           ,(expand-file-name "~/bin/PortableGit/usr/bin")
           ,(expand-file-name "~/bin/Apache-Subversion/bin/")
           ,(expand-file-name "~/bin/svn2git-2.4.0/bin")
           ,(expand-file-name "~/bin/clang/bin")
           ,(expand-file-name "~/bin/find")
           ,(expand-file-name "~/bin/omnisharp-win-x64")
           "c:/GnuWin32/bin"
           "c:/GNAT/2021/bin")))
    (setenv "PATH" (mapconcat 'identity xPaths ";"))
    (setq exec-path (append xPaths (list "." exec-directory))))
  ;;
  (custom-theme-set-faces
   'user
   '(variable-pitch ((t (:family "Consolas" :height 110 :weight normal))))
   '(fixed-pitch ((t ( :family "Consolas" :height 110)))))

  (setq font-general "Consolas 11")
  (set-frame-font font-general nil t)
  (add-to-list 'default-frame-alist `(font . ,font-general)))
;;
(setq tab-bar-show 1)

#+end_src

* linux-specific-core

Curates configurations specific to Linux, making adjustments for paths, fonts, and system integrations ensuring Emacs is well integrated with the Linux desktop environment.

#+begin_src elisp
;;
;; -> linux-specific-core
;;
(when (eq system-type 'gnu/linux)
  (custom-theme-set-faces
   'user
   '(variable-pitch ((t (:family "DejaVu Sans" :height 120 :weight normal))))
   '(fixed-pitch ((t ( :family "Source Code Pro" :height 110)))))
  (setq font-general "Source Code Pro 12")
  (set-frame-font font-general nil t)
  (add-to-list 'default-frame-alist `(font . ,font-general)))
#+end_src

* LLM-core

#+begin_src elisp
;;
;; -> LLM-core
;;
;;
(defun safe-add-to-load-path (dir)
  "Add DIR to `load-path` if it exists."
  (when (file-directory-p dir)
    (add-to-list 'load-path dir)))
;; Add directories to load-path only if they exist
(safe-add-to-load-path (expand-file-name "lisp/shell-maker" user-emacs-directory))
(safe-add-to-load-path (expand-file-name "lisp/chatgpt-shell" user-emacs-directory))
(safe-add-to-load-path (expand-file-name "lisp/gptel" user-emacs-directory))
;; Conditionally require and configure packages if their files exist
(when (locate-library "gptel")
  (require 'gptel)
  (require 'gptel-ollama)
  (require 'gptel-curl)
  (gptel-make-ollama "llama3_2"
    :host "localhost:11434"
    :stream t
    :models '(llama3_2:latest))
  (setq gptel-model 'qwen2.5-coder-7b-instruct-q5_k_m:latest
        gptel-backend (gptel-make-ollama "llama3_2"
                        :host "localhost:11434"
                        :stream t
                        :models '(llama3_2:latest))))
;;
(when (locate-library "shell-maker")
  (require 'shell-maker))
;;
(when (locate-library "chatgpt-shell")
  (require 'chatgpt-shell)
  (setq chatgpt-shell-models
        '(((:provider . "Ollama")
           (:label . "Ollama-llama")
           (:version . "llama3_2")
           (:short-version)
           (:token-width . 4)
           (:context-window . 8192)
           (:handler . chatgpt-shell-ollama--handle-ollama-command)
           (:filter . chatgpt-shell-ollama--extract-ollama-response)
           (:payload . chatgpt-shell-ollama-make-payload)
           (:url . chatgpt-shell-ollama--make-url))))
  (with-eval-after-load 'chatgpt-shell
    (defun chatgpt-shell-menu ()
      "Menu for ChatGPT Shell commands."
      (interactive)
      (let ((key (read-key
                  (propertize
                   "ChatGPT Shell Commands:\n
      e: Explain Code      d: Describe Code           l: Start Shell
      p: Proofread Region  r: Refactor Code           t: Save Session Transcript
      g: Write Git Commit  u: Generate Unit Test      o: Summarize Last Command Output
      s: Send Region       a: Send and Review Region  m: Swap Model\n
        q: Quit\n\nPress a key: " 'face 'minibuffer-prompt))))
        (pcase key
          (?e (call-interactively 'chatgpt-shell-explain-code))
          (?p (call-interactively 'chatgpt-shell-proofread-region))
          (?g (call-interactively 'chatgpt-shell-write-git-commit))
          (?s (call-interactively 'chatgpt-shell-send-region))
          (?d (call-interactively 'chatgpt-shell-describe-code))
          (?r (call-interactively 'chatgpt-shell-refactor-code))
          (?u (call-interactively 'chatgpt-shell-generate-unit-test))
          (?a (call-interactively 'chatgpt-shell-send-and-review-region))
          (?l (call-interactively 'chatgpt-shell))
          (?t (call-interactively 'chatgpt-shell-save-session-transcript))
          (?o (call-interactively 'chatgpt-shell-eshell-summarize-last-command-output))
          (?w (call-interactively 'chatgpt-shell-eshell-whats-wrong-with-last-command))
          (?i (call-interactively 'chatgpt-shell-describe-image))
          (?m (call-interactively 'chatgpt-shell-swap-model))
          (?q (message "Quit ChatGPT Shell menu."))
          (?\C-g (message "Quit ChatGPT Shell menu."))
          (_ (message "Invalid key: %c" key))))))
  (global-set-key (kbd "C-c g") 'chatgpt-shell-menu))

#+end_src

* programming-core

#+begin_src elisp
;;
;; -> programming-core
;;
;;
(defun my/eglot-dir-locals ()
  "Create .dir-locals.el file for eglot ada-mode using the selected DIRED path."
  (interactive)
  (add-dir-local-variable
   'ada-mode
   'eglot-workspace-configuration
   `((ada . (:projectFile ,(dired-get-filename))))))
;;
(setq vc-handled-backends '(SVN Git))
;;
;; all-purpose build menu
;;
(defvar cmake-preset
  "build/linux/debug"
  "cmake-preset")
;;
(defun change-directory-and-run (dir command bufname)
  "Change to DIR and run the COMMAND."
  (let ((default-directory dir))
    (async-shell-command command bufname)
    (message "Running command: %s:%s" dir command)))
;;
(defun run-exe-command (dir exe bufname)
  "Run EXE from a specified DIR."
  (message "run-exe-command: %s:%s:%s" dir exe bufname)
  (change-directory-and-run dir exe bufname))
;;
(defun run-cmake-command (command)
  "Run COMMAND from the top level of the project."
  (message command)
  (change-directory-and-run (project-root (project-current t)) command "*cmake*"))
;;
(defun run-cmake-compile-command (command)
  "Run compile COMMAND from the top level of the project."
  (message command)
  (let ((default-directory (project-root (project-current t))))
    (compile command)
    (message "Running command: %s:%s" dir command)))
;;
(defun kill-async-buffer (buffer-name)
  "Kill the async buffer with BUFFER-NAME."
  (let ((buffer (get-buffer buffer-name)))
    (when buffer
      (kill-buffer buffer)
      (message "Killed buffer: %s" buffer-name))))
;;
(defun list-cmake-presets ()
  "List available CMake presets using `cmake --list-presets=configure`."
  (let ((output (shell-command-to-string "cmake --list-presets=configure")))
    (delq nil
          (mapcar (lambda (line)
                    (if (string-match "^\\s-+\"\\([^\"]+\\)\"\\s-*$" line)
                        (match-string 1 line)))
                  (split-string output "\n")))))
;;
(defun transient-select-cmake-preset ()
  "Function to select a CMake preset."
  (interactive)
  (let* ((presets (list-cmake-presets))
         (preset (completing-read "Select CMake preset: " presets nil t)))
    (setq cmake-preset preset)
    (message "Selected CMake preset: %s" preset)))
;;
(defun build-menu ()
  "Menu for Build and Diagnostic commands (Horizontal Layout)."
  (interactive)
  (let ((key (read-key
              (propertize
               (concat
                "Build and Diagnostic Commands:\n"
                "\n"
                "CMake: [p: Set Preset] [c: Configure] [RET: Build] [i: Install] [g: Refresh] [x: Clean] [s: List Presets]\n"
                "Actions: [f: Toggle Flycheck] [d: Show Diagnostics]\n"
                "Coding: [e: Eglot & Flymake] [u: Undo Eglot & Flymake] [h: Stop Eglot]\n"
                "Run: [r: All] [1: CigiDummyIG] [2: CigiMiniHost] [3: CigiMiniHostCSharp]\n"
                "Kill: [5: Kill CigiDummyIG] [6: Kill CigiMiniHost] [7: Kill CigiMiniHostCSharp] [k: Kill All]\n"
                "\n"
                "Press 'q' to Quit\n\n"
                "Press a key: ")
               'face 'minibuffer-prompt))))
    (pcase key
      ;; CMake Commands
      (?p (call-interactively 'transient-select-cmake-preset))
      (?c (run-cmake-command (format "cmake --preset %s" cmake-preset)))
      (?\r (run-cmake-compile-command (format "cmake --build --preset %s" cmake-preset)))
      (?i (run-cmake-command (format "cmake --install %s" cmake-preset)))
      (?g (run-cmake-command (format "cmake --preset %s --fresh" cmake-preset)))
      (?x (when (y-or-n-p "Are you sure you want to proceed? ")
            (run-cmake-command "rm -rf build")))
      (?s (run-cmake-command "cmake --list-presets=configure"))
      ;; Actions
      (?f (flymake-mode))
      (?d (flymake-show-buffer-diagnostics))
      ;; Coding
      (?e (progn (call-interactively 'eglot) (flymake-mode 1)))
      (?u (progn (eglot-shutdown-all) (flymake-mode -1)))
      (?h (eglot-shutdown-all))
      ;; Run Commands
      (?r (progn
            (run-exe-command
             (concat (project-root (project-current t))
                     "build/windows/debug/bin/Debug")
             "CigiDummyIG.exe" "*Running CigiDummyIG.exe*")
            (run-exe-command
             (concat (project-root (project-current t))
                     "build/windows/debug/bin/Debug")
             "CigiMiniHostCSharp.exe" "*Running CigiMiniHostCSharp.exe*")))
      (?1 (run-exe-command
           (concat (project-root (project-current t))
                   "build/windows/debug/bin/Debug")
           "CigiDummyIG.exe"
           "*Running CigiDummyIG.exe*"))
      (?2 (run-exe-command
           (concat (project-root (project-current t))
                   "build/windows/debug/bin/Debug")
           "CigiMiniHost.exe"
           "*Running CigiMiniHost.exe*"))
      (?3 (run-exe-command
           (concat (project-root (project-current t))
                   "build/windows/debug/bin/Debug")
           "CigiMiniHostCSharp.exe"
           "*Running CigiMiniHostCSharp.exe*"))
      ;; Kill Commands
      (?5 (kill-async-buffer "*Running CigiDummyIG.exe*"))
      (?6 (kill-async-buffer "*Running CigiMiniHost.exe*"))
      (?7 (kill-async-buffer "*Running CigiMiniHostCSharp.exe*"))
      (?k (progn
            (kill-async-buffer "*Running CigiDummyIG.exe*")
            (kill-async-buffer "*Running CigiMiniHost.exe*")
            (kill-async-buffer "*Running CigiMiniHostCSharp.exe*")))
      ;; Quit
      (?q (message "Quit Build menu."))
      (?\C-g (message "Quit Build menu."))
      ;; Default Invalid Key
      (_ (message "Invalid key: %c" key)))))
;;
(global-set-key (kbd "M-RET") #'build-menu)
#+end_src

* ada-core

Taken originally from :

https://github.com/sebastianpoeplau/ada-light-mode

** A lightweight Ada mode for Emacs

=ada-light-mode= is a very light alternative to [[https://www.nongnu.org/ada-mode/][=ada-mode=]]. It depends only on the =compat= library for compatibility with older Emacs versions, and it aims to be easy to set up, fast, and reliable.

*** Features

- Highlight reserved words of the language
- Identify comments and strings, so that you can use the usual commands for (un)commenting, as well as Emacs features for spell-checking, URL detection, etc.
- Imenu support for subprograms, packages, and types

You can combine =ada-light-mode= with the [Ada language server](https://github.com/AdaCore/ada/language/server) for more advanced features (see below).

*** Language server integration

The [[https://github.com/AdaCore/ada/language/server][Ada language server]] can enhance =ada-light-mode= with LSP features like documentation lookup, jump-to-definition, refactoring, and on-the-fly error checking. This section documents how to set it up with [[https://github.com/joaotavora/eglot][=eglot=]]; the alternative [[https://emacs-lsp.github.io/lsp-mode/][=lsp-mode=]] should work too but will require additional work.

First, install =eglot= (e.g., via =M-x package-install RET eglot RET=) and make sure that the =ada/language/server= binary is on your =PATH=. Then, create a =.dir-locals.el= file in your project to tell the language server where to find the Ada project definition:

#+begin_src elisp :tangle no
;;; Directory Local Variables
;;; For more information see (info "(emacs) Directory Variables")
((ada-light-mode . ((eglot-workspace-configuration . (:ada
                                                      (:projectFile "/path/to/project.gpr"))))))
#+end_src

Finally, open a source file and run =M-x eglot= to start the language server.

When =eglot= is active, indentation uses the language server's formatting capabilities to indent code (i.e., [[https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_rangeFormatting][=textDocument.rangeFormatting=]]).  It actually does a bit more than that, possibly breaking the to-be-indented line up into multiple lines if that's how the language server suggests to format it. Note that the Ada language server sometimes modifies code beyond the current line in response to such a request. This can be especially confusing when you simply inserted a newline - automatic indentation of the just-finished line triggers the undesired behavior. In such cases, you can insert the newline with =C-j= to circumvent automatic indentation.

The Ada language server uses on-type formatting to insert space characters whenever you type a newline. This behavior doesn't work well with Emacs' own indentation logic; the language server's space characters end up _after_ point.  You may want to disable on-type formatting to work around this issue:

#+begin_src elisp :tangle no
(push :documentOnTypeFormattingProvider eglot-ignored-server-capabilities)
#+end_src

The Ada language server exposes a custom command =als-other-file= that lets you jump between specification and body files; use it with `M-x ada-light-other-file= (after starting =eglot`) or bind the command to a key for easy access.

#+begin_src elisp
;;
;; -> ada-core
;;
(defvar ada-light-mode-keywords
  ;; https://www.adaic.org/resources/add_content/standards/05rm/html/RM-2-9.html
  '("abort" "else" "new" "return" "abs" "elsif" "not" "reverse" "abstract" "end"
    "null" "accept" "entry" "select" "access" "exception" "of" "separate"
    "aliased" "exit" "or" "subtype" "all" "others" "synchronized" "and" "for"
    "out" "array" "function" "overriding" "tagged" "at" "task" "generic"
    "package" "terminate" "begin" "goto" "pragma" "then" "body" "private" "type"
    "if" "procedure" "case" "in" "protected" "until" "constant" "interface"
    "use" "is" "raise" "declare" "range" "when" "delay" "limited" "record"
    "while" "delta" "loop" "rem" "with" "digits" "renames" "do" "mod" "requeue"
    "xor")
  "Keywords of the Ada 2012 language.")
;;
(defvar ada-light-mode--font-lock-rules
  (list (regexp-opt ada-light-mode-keywords 'symbols))
  "Rules for search-based fontification in `ada-light-mode'.
The format is appropriate for `font-lock-keywords'.")
;;
(defvar ada-light-mode-syntax-table     ; used automatically by define-derived-mode
  (let ((table (make-syntax-table)))
    ;; Comments start with "--".
    (modify-syntax-entry ?- ". 12" table)
    ;; Newlines end comments.
    (modify-syntax-entry ?\n ">" table)
    (modify-syntax-entry ?\r ">" table)
    ;; Backslash is a regular symbol, not an escape character.
    (modify-syntax-entry ?\\ "_" table)
    table)
  "Syntax table used in `ada-light-mode'.")
;;
(defvar ada-light-mode-other-file-alist
  '(("\\.ads\\'" (".adb"))
    ("\\.adb\\'" (".ads")))
  "Value for `ff-other-file-alist' in `ada-light-mode'.")
;;
(defun ada-light-mode--syntax-propertize (start end)
  "Apply syntax properties to the region from START to END."
  ;; Ada delimits character literals with single quotes, but also uses the
  ;; single quote for other purposes. Since character literals are always
  ;; exactly one character long (i.e., there are no escape sequences), we can
  ;; easily find them with a regular expression and change the syntax class of
  ;; the enclosing single quotes to "generic string". This also nicely handles
  ;; the case of '"': generic string delimiters only match other generic string
  ;; delimiters, but not ordinary quote characters (i.e., the double quote).
  (goto-char start)
  (while-let ((pos (re-search-forward "'.'" end t)))
    (put-text-property (- pos 3) (- pos 2) 'syntax-table '(15))
    (put-text-property (- pos 1) pos 'syntax-table '(15))))
;;
(defvar ada-light-mode--imenu-rules
  `(("Functions"
     ,(rx bol
          (* space)
          (? (? "not" (* space)) "overriding" (* space))
          "function"
          (+ space)
          (group (+ (or word (syntax symbol)))))
     1)
    ("Procedures"
     ,(rx bol
          (* space)
          (? (? "not" (* space)) "overriding" (* space))
          "procedure"
          (+ space)
          (group (+ (or word (syntax symbol)))))
     1)
    ("Types"
     ,(rx bol
          (* space)
          (? "sub")
          "type"
          (+ space)
          (group (+ (or word (syntax symbol)))))
     1)
    ("Packages"
     ,(rx bol
          (* space)
          "package"
          (+ space)
          (group (+ (or word (syntax symbol))))
          (+ space)
          "is")
     1))
  "Imenu configuration for `ada-light-mode'.
The format is appropriate for `imenu-generic-expression'.")
;;
(defun ada-light-mode--indent-line ()
  "Indent a single line of Ada code."
  ;; This is a really dumb implementation which just indents to the most recent
  ;; non-empty line's indentation. It's better than the default though because
  ;; it stops there, so that users who want completion on TAB can get it after
  ;; indenting. (The default behavior is to insert TAB characters indefinitely.)
  (let ((indent (save-excursion
                  (beginning-of-line)
                  (if (re-search-backward "^[^\n]" nil t) ; non-empty line
                      (current-indentation)
                    0))))
    (if (<= (current-column) (current-indentation))
        (indent-line-to indent)
      (when (< (current-indentation) indent)
        (save-excursion (indent-line-to indent))))))
;;
;;;###autoload
(define-derived-mode ada-light-base-mode prog-mode "AdaLBase"
  "Base mode for `ada-light-mode' and `gpr-light-mode'."
  ;; Set up commenting; Ada uses "--" followed by two spaces.
  (setq-local comment-use-syntax t
              comment-start "--"
              comment-padding 2)
  ;; Set up fontification.
  (setq-local font-lock-defaults '(ada-light-mode--font-lock-rules nil t)
              syntax-propertize-function #'ada-light-mode--syntax-propertize)
  ;; And finally, configure indentation. Since our indentation function isn't
  ;; particularly good, don't force it upon the user.
  (setq-local standard-indent 3
              tab-width 3               ; used by eglot for range formatting
              indent-line-function 'ada-light-mode--indent-line
              electric-indent-inhibit t))
;;
;;;###autoload
(define-derived-mode ada-light-mode ada-light-base-mode "AdaL"
  "Major mode for the Ada programming language.
It doesn't define any keybindings. In comparison with `ada-mode',
`ada-light-mode' is faster but less accurate."
  (setq-local ff-other-file-alist ada-light-mode-other-file-alist
              imenu-generic-expression ada-light-mode--imenu-rules))
;;
;;;###autoload
(define-derived-mode gpr-light-mode ada-light-base-mode "GPRL"
  "Major mode for GPR project files."
  :syntax-table ada-light-mode-syntax-table)
;;
;; Register the mode for Ada code following GNAT naming conventions.
;;;###autoload
(progn (add-to-list 'auto-mode-alist '("\\.ad[abcs]\\'" . ada-light-mode))
       (add-to-list 'auto-mode-alist '("\\.gpr\\'" . gpr-light-mode)))
;;
;; Configure eglot if available.
(with-eval-after-load 'eglot
  (add-to-list 'eglot-server-programs '((ada-light-mode :language-id "ada")
                                        "ada_language_server"))
  ;; The Ada Language Server doesn't support formatting .gpr files, but it
  ;; provides completion and detects syntax errors.
  (add-to-list 'eglot-server-programs '((gpr-light-mode :language-id "ada")
                                        "ada_language_server" "--language-gpr"))
  (defun ada-light-other-file ()
    "Jump from spec to body or vice versa using the Ada Language Server."
    (interactive)
    (if-let ((server (eglot-current-server)))
        (eglot-execute-command server
                               "als-other-file"
                               (vector (eglot--TextDocumentIdentifier)))
      (message "%s" "Not connected to the Ada Language Server")))
  ;; The "als-other-file" command used by `ada-light-other-file' requires
  ;; support for the "window/showDocument" server request in eglot; add it if
  ;; necessary.
  (unless (cl-find-method 'eglot-handle-request nil '(t (eql window/showDocument)))
    (cl-defmethod eglot-handle-request
      (_server (_method (eql window/showDocument)) &key uri &allow-other-keys)
      (find-file (eglot--uri-to-path uri))
      (list :success t)))
  ;;
  (defun ada-light-mode--current-line-empty-p ()
    (save-excursion
      (beginning-of-line)
      (looking-at-p (rx (* space) eol))))
  ;;
  (defun ada-light-mode--indent-line-eglot ()
    "Indent the current line using the Ada Language Server."
    (interactive)
    (if (ada-light-mode--current-line-empty-p)
        ;; Let's not "indent" empty lines with the language server, it would
        ;; just delete them. Instead, take a guess at the required indentation
        ;; based on the most recent non-empty line.
        (indent-relative t t)
      (condition-case err
          (eglot-format (line-beginning-position) (line-end-position))
        ;; When `eglot-format' fails due to a server issue it signals the
        ;; underlying `jsonrpc-error'. In this case, let's return normally to
        ;; give completion a chance.
        (jsonrpc-error
         (when-let ((msg (alist-get 'jsonrpc-error-message (cdr err))))
           (message "Language server error: %s" msg))
         nil))))
  ;;
  (defun ada-light-mode--eglot-setup ()
    "Set up `eglot' integration for `ada-light-mode'."
    (when (eq major-mode 'ada-light-mode)
      (if (eglot-managed-p)
          (setq-local indent-line-function 'ada-light-mode--indent-line-eglot
                      electric-indent-inhibit nil)
        (setq-local indent-line-function 'ada-light-mode--indent-line
                    electric-indent-inhibit t))))
  ;;
  (add-hook 'eglot-managed-mode-hook #'ada-light-mode--eglot-setup))
;;
(provide 'ada-light-mode)
#+end_src

* development-core

#+begin_src elisp
;;
;; -> development-core
;;
(global-set-key (kbd "C-c t") 'toggle-centered-buffer)
;;
(defun my/md-to-org-convert-buffer ()
  "Convert the current buffer from Markdown to Org-mode format"
  (interactive)
  (save-excursion
    ;; Lists: Translate `-`, `*`, or `+` lists to Org-mode lists
    (goto-char (point-min))
    (while (re-search-forward "^\\([ \t]*\\)[*-+] \\(.*\\)$" nil t)
      (replace-match (concat (match-string 1) "- \\2")))
    ;; Bold: `**bold**` -> `*bold*` only if directly adjacent
    (goto-char (point-min))
    (while (re-search-forward "\\*\\*\\([^ ]\\(.*?\\)[^ ]\\)\\*\\*" nil t)
      (replace-match "*\\1*"))
    ;; Italics: `_italic_` -> `/italic/`
    (goto-char (point-min))
    (while (re-search-forward "\\b_\\([^ ]\\(.*?\\)[^ ]\\)_\\b" nil t)
      (replace-match "/\\1/"))
    ;; Links: `[text](url)` -> `[[url][text]]`
    (goto-char (point-min))
    (while (re-search-forward "\\[\\(.*?\\)\\](\\(.*?\\))" nil t)
      (replace-match "[[\\2][\\1]]"))
    ;; Code blocks: Markdown ```lang ... ``` to Org #+begin_src ... #+end_src
    (goto-char (point-min))
    (while (re-search-forward "```\\(.*?\\)\\(?:\n\\|\\s-\\)\\(\\(?:.\\|\n\\)*?\\)```" nil t)
      (replace-match "#+begin_src \\1\n\\2#+end_src"))
    ;; Inline code: `code` -> =code=
    (goto-char (point-min))
    (while (re-search-forward "`\\(.*?\\)`" nil t)
      (replace-match "=\\1="))
    ;; Horizontal rules: `---` or `***` -> `-----`
    (goto-char (point-min))
    (while (re-search-forward "^\\(-{3,}\\|\\*{3,}\\)$" nil t)
      (replace-match "-----"))
    ;; Images: `![alt text](url)` -> `[[url]]`
    (goto-char (point-min))
    (while (re-search-forward "!\\[.*?\\](\\(.*?\\))" nil t)
      (replace-match "[[\\1]]"))
    (goto-char (point-min))
    ;; Headers: Adjust '#'
    (while (re-search-forward "^\\(#+\\) " nil t)
      (replace-match (make-string (length (match-string 1)) ?*) nil nil nil 1))))
;;
(defun my/md-to-org-convert-file (input-file output-file)
  "Convert a Markdown file INPUT-FILE to an Org-mode file OUTPUT-FILE."
  (with-temp-buffer
    (insert-file-contents input-file)
    (md-to-org-convert-buffer)
    (write-file output-file)))
;;
(defun my/convert-markdown-clipboard-to-org ()
  "Convert Markdown content from clipboard to Org format and insert it at point."
  (interactive)
  (let ((markdown-content (current-kill 0))
        (original-buffer (current-buffer)))
    (with-temp-buffer
      (insert markdown-content)
      (my/md-to-org-convert-buffer)
      (let ((org-content (buffer-string)))
        (with-current-buffer original-buffer
          (insert org-content))))))
;;
(defun my/org-promote-all-headings (&optional arg)
  "Promote all headings in the current Org buffer along with their subheadings."
  (interactive "p")
  (org-map-entries
   (lambda () 
     (dotimes (_ arg) (org-promote)))))
;;
(global-set-key (kbd "M-s i") #'my/convert-markdown-clipboard-to-org)
(global-set-key (kbd "M-s u") #'my/org-promote-all-headings)
;;
(defun my-icomplete-copy-candidate ()
  "Copy the current Icomplete candidate to the kill ring."
  (interactive)
  (let ((candidate (car completion-all-sorted-completions)))
    (when candidate
      (kill-new (substring-no-properties candidate))
      (abort-recursive-edit))))
;;
(define-key minibuffer-local-completion-map (kbd "C-c ,") 'my-icomplete-copy-candidate)
;;
(defun prot/keyboard-quit-dwim ()
  "Do-What-I-Mean behaviour for a general `keyboard-quit'.
    The generic `keyboard-quit' does not do the expected thing when
    the minibuffer is open.  Whereas we want it to close the
    minibuffer, even without explicitly focusing it.
    The DWIM behaviour of this command is as follows:
    - When the region is active, disable it.
    - When a minibuffer is open, but not focused, close the minibuffer.
    - When the Completions buffer is selected, close it.
    - In every other case use the regular `keyboard-quit'."
  (interactive)
  (cond
   ((region-active-p)
    (keyboard-quit))
   ((derived-mode-p 'completion-list-mode)
    (delete-completion-window))
   ((> (minibuffer-depth) 0)
    (abort-recursive-edit))
   (t
    (keyboard-quit))))
;;
(define-key global-map (kbd "C-g") #'prot/keyboard-quit-dwim)
;;
(add-to-list 'display-buffer-alist
             '("\\*my-rg-results"
               (display-buffer-reuse-window display-buffer-in-direction)
               (direction . leftmost)
               (dedicated . t)
               (window-width . 0.33)
               (inhibit-same-window . t)))
;;
(defun without-gc (&rest args)
  (let ((gc-cons-threshold most-positive-fixnum))
    (apply args)))
#+end_src

* emacs-enhanced

The defun replacements which are loaded from the generated .el file which will be tangled separately.

#+begin_src elisp
;;
;; -> core-configuration
;;
(load-file "~/.emacs.d/Emacs-enhanced/init.el")
#+end_src

* image-dired

Customizes the behaviour and appearance of Image-Dired, the image management extension of Dired, streamlining the browsing and manipulation of image files.

#+begin_src elisp
;;
;; -> image-dired
;;
(require 'image-mode)
(require 'image-dired)
;;
(add-to-list 'display-buffer-alist
             '("\\*image-dired\\*"
               display-buffer-in-direction
               (direction . left)
               (window . root)
               (window-width . 0.5)))
;;
(add-to-list 'display-buffer-alist
             '("\\*image-dired-display-image\\*"
               display-buffer-in-direction
               (direction . right)
               (window . root)
               (window-width . 0.5)))
;;
(defun my/image-dired-sort (arg)
  "Sort images in various ways given ARG."
  (interactive "P")
  ;; Use `let` to temporarily set `dired-actual-switches`
  (let ((dired-actual-switches
         (cond
          ((equal arg nil)            ; no C-u
           "-lGghat --ignore=*.xmp")
          ((equal arg '(4))           ; C-u
           "-lGgha --ignore=*.xmp")
          ((equal arg 1)              ; C-u 1
           "-lGgha --ignore=*.xmp"))))
    (let ((w (selected-window)))
      (delete-other-windows)
      (revert-buffer)
      (image-dired ".")
      (let ((idw (selected-window)))
        (select-window w)
        (dired-unmark-all-marks)
        (select-window idw)
        (image-dired-display-this)
        (image-dired-line-up-dynamic)))))
;;
(setq image-use-external-converter t)
(setq image-dired-external-viewer "/usr/bin/gthumb")
(setq image-dired-show-all-from-dir-max-files 999)
(setq image-dired-thumbs-per-row 999)
(setq image-dired-thumb-relief 0)
(setq image-dired-thumb-margin 5)
(setq image-dired-thumb-size 120)
;;
(defun my/image-save-as ()
  "Save the current image buffer as a new file."
  (interactive)
  (let* ((file (buffer-file-name))
         (dir (file-name-directory file))
         (name (file-name-nondirectory file))
         (base-name (file-name-sans-extension name))
         (extension (file-name-extension name t))
         (initial_mode major-mode)
         (counter 1)
         (new-file))
    (while (and (setq new-file
                      (format "%s%s_%03d%s" dir base-name counter extension))
                (file-exists-p new-file))
      (setq counter (1+ counter)))
    (write-region (point-min) (point-max) new-file nil 'no-message)
    (revert-buffer nil t nil)
    ;; (delete-file file t)
    (if (equal initial_mode 'image-dired-image-mode)
        (progn
          (image-dired ".")
          (image-dired-display-this))
      (find-file new-file t))))
;;
(defun my/delete-current-image-and-move-to-next ()
  "Delete the current image file and move to the next image in the directory."
  (interactive)
  (let ((current-file (buffer-file-name)))
    (when current-file
      (image-next-file 1)
      (delete-file current-file)
      (message "Deleted %s" current-file))))
;;
(defun my/delete-current-image-thumbnails ()
  "Delete the current image file and move to the next image in the directory."
  (interactive)
  (let ((file-name (image-dired-original-file-name)))
    (delete-file file-name)
    (image-dired-delete-char)
    (image-dired-display-this)))
;;
(eval-after-load 'image-mode
  '(progn
     (define-key image-mode-map (kbd "C-d") 'my/delete-current-image-and-move-to-next)
     (define-key image-mode-map (kbd "C-x C-s") 'my/image-save-as)))
;;
(eval-after-load 'image-dired
  '(progn
     (define-key image-dired-thumbnail-mode-map (kbd "C-d") 'my/delete-current-image-thumbnails)
     (define-key image-dired-thumbnail-mode-map (kbd "n")
                 (lambda ()(interactive)(image-dired-forward-image)(image-dired-display-this)))
     (define-key image-dired-thumbnail-mode-map (kbd "p")
                 (lambda ()(interactive)(image-dired-backward-image)(image-dired-display-this)))
     ))
#+end_src

* dwim

Demonstrates "Do What I Mean" functionalities custom to Emacs, streamlining operations like conversion, searching, and executing context-aware actions.

#+begin_src elisp
;;
;; -> dwim
;;

(when (file-exists-p "/home/jdyer/bin/category-list-uniq.txt")
  (progn
    (defvar my/dwim-convert-commands
      '("ConvertNoSpace" "AudioConvert" "AudioInfo" "AudioNormalise"
        "AudioTrimSilence" "PictureAutoColour" "PictureConvert"
        "PictureCrush" "PictureFrompdf" "PictureInfo" "PictureMontage"
        "PictureOrganise" "PictureCrop" "PictureRotateFlip" "PictureEmail"
        "PictureUpdateFromCreateDate"
        "PictureRotateLeft" "PictureRotateRight" "PictureScale"
        "PictureUpscale" "PictureGetText" "PictureOrientation"
        "PictureUpdateToCreateDate" "VideoConcat" "VideoConvert" "VideoConvertToGif"
        "VideoCut" "VideoDouble" "VideoExtractAudio" "VideoExtractFrames"
        "VideoFilter" "VideoFromFrames" "VideoInfo" "VideoRemoveAudio"
        "VideoReplaceVideoAudio" "VideoRescale" "VideoReverse"
        "VideoRotate" "VideoRotateLeft" "VideoRotateRight" "VideoShrink"
        "VideoSlowDown" "VideoSpeedUp" "VideoZoom" "WhatsAppConvert"
        "PictureCorrect" "Picture2pdf" "PictureTag" "PictureTagRename"
        "OtherTagDate" "VideoRemoveFlips")
      "List of commands for dwim-convert.")

    (defun my/read-lines (file-path)
      "Return a list of lines of a file at FILE-PATH."
      (with-temp-buffer
        (insert-file-contents file-path)
        (split-string (buffer-string) "\n" t)))

    (defun my/dwim-convert-generic (command)
      "Execute a dwim-shell-command-on-marked-files with the given COMMAND."
      (let* ((unique-text-file "~/bin/category-list-uniq.txt")
             (user-selection nil)
             (files (dired-get-marked-files nil current-prefix-arg))
             (command-and-files (concat command " " (mapconcat 'identity files " "))))
        (when (string= command "PictureTag")
          (setq user-selection (completing-read "Choose an option: "
                                                (my/read-lines unique-text-file)
                                                nil t)))
        (async-shell-command (if user-selection
                                 (concat command " " user-selection " " (mapconcat 'identity files " "))
                               (concat command " " (mapconcat 'identity files " ")))
                             "*convert*")))

    (defun my/dwim-convert-with-selection ()
      "Prompt user to choose command and execute dwim-shell-command-on-marked-files."
      (interactive)
      (let ((chosen-command (completing-read "Choose command: "
                                             my/dwim-convert-commands)))
        (my/dwim-convert-generic chosen-command)))

    (global-set-key (kbd "C-c v") 'my/dwim-convert-with-selection)))

#+end_src

* Notes

- This configuration intentionally avoids external Emacs packages like `use-package` or `straight.el` to maintain simplicity and remove the requirement for package management.
- Tested on both Linux (SLES15) and Windows environments for compatibility and portability.
